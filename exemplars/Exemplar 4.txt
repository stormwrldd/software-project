
Defining the problem ............................................................................................................................. 4
Identification of the problem (Problem statement) ........................................................................... 4
Communication to establish requirements (Interviews, observation and questionnaires)................ 4
Idea generation (Alternative solutions) .............................................................................................. 5
Investigate alternative approaches to a software solution (feasibility study).................................... 5
Requirements (Numbered list) ............................................................................................................ 5
Develop project plan (Development approach used and Gantt chart) ............................................... 6
Understanding User Requirements ....................................................................................................... 7
Design specifications ........................................................................................................................... 7
1.

Data types selected ................................................................................................................. 7

2.

Appropriate data structures ................................................................................................... 7

Representation of the system using diagrams (CASE tools) ............................................................... 8
1.

Storyboard .............................................................................................................................. 8

2.

IPO chart ................................................................................................................................. 9

3.

Context diagram.................................................................................................................... 10

4.

DFD ........................................................................................................................................ 10

5.

Initial structure chart ............................................................................................................ 11

Limited prototype development ....................................................................................................... 11
Consider all Social and Ethical issues that apply ............................................................................... 12
Planning and design .............................................................................................................................. 13
Interface design (Consistent, accessible, user-friendly design)......................................................... 13
Selection of software environment (OS and programming language) ............................................ 14
Identification of appropriate hardware ............................................................................................ 14
Data dictionary (Initial) ..................................................................................................................... 14
Definition of required validation processes ...................................................................................... 15
Definition of files ............................................................................................................................... 15
Define Record Format and Creation ................................................................................................. 15
Algorithm design – Structure charts and Pseudocode for main modules: ....................................... 16
(Uses modular structure with appropriate control structures. Inclusion of standard or common
routines) ............................................................................................................................................ 16
Test plan............................................................................................................................................ 18
Enabling and incorporating feedback from users at regular intervals ............................................. 18
Use of CASE Tools ............................................................................................................................. 19
Implementation .................................................................................................................................... 19
Tools and modules used ................................................................................................................... 19
2

Data dictionary (Final)....................................................................................................................... 20
Solution testing and improvements.................................................................................................. 22
Test plan............................................................................................................................................ 23
System and User documentation...................................................................................................... 24
Evidence of online help ..................................................................................................................... 24
Evidence of regular communication with stakeholders ................................................................... 25
Evaluation ............................................................................................................................................. 25
Testing of user requirements ............................................................................................................ 25
Feedback ........................................................................................................................................... 25
Evaluation of ethical and social considerations ................................................................................ 26
Appendices............................................................................................................................................ 27
References and resources (Cited in APA 7 formatting) .................................................................... 27
Project logbook ................................................................................................................................. 27
Survey................................................................................................................................................ 27
Full code listing ................................................................................................................................. 30

3

Defining the problem
 (Problem statement)
Children who are first having access to computers often find it challenging to type quickly
and can often teach themselves to type with one finger at a time, which is very slow and will
be detrimental for their future. Typing tutorials online can be very boring and not
motivating for young children and they can lose interest quickly, so they don’t learn the skill
to type quickly with all fingers which can be vital for their future.

 (Interviews, observation and
questionnaires)
I have created a survey (See appendices) asking people questions like how they learned to
type, if they would like to learn to type faster, and what they would like to see in a typing
game. I sent it to 13 people, and 7 responded. Below are some questions and the most
common responses:
x
x
x
x
x

About half of the people said they were a little slow at typing and 6/7 of the
respondents said that they wanted to learn to type faster.
6/7 respondents said they were able to type with both hands.
4/7 respondents had to teach themselves how to type and 3/7 used typing games to
learn.
Of the 4 that taught themselves, 3 wished that they could type faster.
Here are the respondents’ ideas on what to include in a typing game:
o Have a storyline to follow along
o Unlock skins/cosmetics and achievements as you play more and improve
o Have different levels of difficulty
o Typing faster moves a character faster in some sort of race
o Multiplayer capability

I found it interesting to see that the majority of people who answered my survey wished
that they could type faster, and more than half had to teach themselves how to type.
Especially in the growing age of technology, this issue is relevant enough to base this major
project on.
Additionally, I have had informal discussions with multiple potential users, asking if they
wished they could type faster, how they learnt to type, and if they would like to be a beta
tester. Four out of five of them said they would like to type faster and all five wanted to be
beta testers.

4

(Alternative solutions)
A non-software solution could be to manually teach people in the target audience how to
type, and act as a typing tutor.
I could make a program that teaches people how to type. Because my primary goal is to
teach children who are new to typing how to type faster and with all fingers, it will need to
be interesting and entertaining enough to capture their interest and make them want to try
daily to develop the skill. My typing tutorial could therefore be transformed into a fun game
that teaches along the way.
My initial basic ideas are the following:
A running race where the more correct words you type quickly, the faster the character’s
runner moves. Perhaps motivation could be that the more points you get overall, the more
customizable your character becomes.
A simple to code game like Snake where players must type a few sentences without
mistakes to get to play the game.
In all games, there could be different levels of difficulty, and a basic multiplayer function
where one player has their turn, then passes the keyboard off to the next.
Ultimately, I chose the running race because it seems to be not too complicated while still
being fun.

 (feasibility study)
An alternative approach to this software solution that I am working on is to have an actual person as
a typing tutor who helps a student learn how to type by showing them how, working with them as
they type out words, and giving them homework. However, there are multiple downsides to this that
my approach entirely avoids. Most importantly, having a human teacher costs money. From a quick
search online, these cost from $13 to $45 per hour. Being an online tutorial/game, my solution is
completely free, and it also avoids the inconvenience of having to leave your house. Additionally,
some students may be more comfortable learning how to type without the pressure of having to
show someone their weekly improvements, and may become disheartened if they haven’t made
enough progress that someone else was counting on, and might want to quit.

(Numbered list)
1.
2.
3.
4.
5.

Must give users messages to type.
Must record and display the accuracy of the user’s response.
Must record and display the words per minute typed by the user.
Must look visually appealing.
Must have some sort of game aspect to make it entertaining (e.g. rewards system, racing
game, having a storyline)
6. Must be varied enough that you can play it multiple times and not get bored.
5

Boundaries: The game will likely only work on Windows because I will be using Pycharm to export
the game as an executable file. The minimum requirements for Pycharm are 4GB RAM, any modern
CPU, 2.5GB disc space and 1GB extra space for caches, a monitor resolution of 1024x768, and an OS
of Windows 8. However, these are the bare minimum requirements and the recommended ones are
8GB RAM, a multi-core CPU, 5GB disc space, a monitor resolution of 1920x1080, and the latest 64-bit
version of Windows.
Constraints: I am not a professional software designer so a major constraint will be my skills and
abilities surrounding Python and Pycharm. I have chosen a rather specific topic compared to other
generic games (e.g. platform games, text games, draughts, hangman, etc.), and there are less
resources online to aid with typing games in python so if I run into any problems, I will have to solve
them myself which may take an extensive amount of time, deducting from the amount that I can
work on the game. There are limited words in the list, limited characters, and ultimately limited and
repetitive gameplay.
Social and Ethical Standards: My game has a demographic of children, so it must be entirely
appropriate for them; there must only be appropriate language and images. I must ensure the
software itself is entirely safe and will not harm the user’s system in any way. My code and sprites
must not be plagiarised and if I use code from other sources they must be open source and copyright
free.


 (Development approach used and Gantt chart)
I will be using the agile approach for my project because it allows for lots of trial and error
with my game. The main reason I am doing this is because I am not a master coder by any
means, and I have been a little too ambitious in previous projects, having to lower my goals
after beginning my project.
I will first plan my requirements for my project, using this documentation to record my
thoughts for what I should do, then I will develop my product, which will be over the course
of several weeks, with documentation in between. I will be able to test my software
constantly throughout this time, showing it to my target audience and gaining feedback,
which I will combine with my own opinions of what should be changed to improve the
project.
I have started my project by creating a Gantt chart to ensure I do not get lost along the way
and have a very structured outline of the next two terms. See my Gantt chart below.

6

Understanding User Requirements 
  
ͳǤ  
Variable
screenDisplay
volume
colourBlindMode
difficultySelected

Data Type
string
float
string
string

Example/s
“helpScreen”
64.7
“off”, “dueteranopia”
“Medium”

correctLetters
integer
16
totalLettersTyped
integer
4
incorrectLetters
integer
0
totalLettersTyped
integer
42
timeTaken
integer
32
totalTimeTaken
integer
79
isGameRunning
Boolean
True
The above data types were used as each was the simplest one for the requirement. For example,
correctLetters is an integer rather than a floating point or string, because it will only ever be a whole
number, and due to it being used in calculations a string is not appropriate to hold the information.
Another example, isGameRunning, is a Boolean rather than a string or integer, because although
they could achieve the same effect (if isGameRunning == “Yes”, or if isGameRunning == 1, rather
than if isGameRunning == True), it is just simpler and more efficient to use a Boolean.

ʹǤ  
I have used appropriate data structures such as arrays and Python dictionaries to store information
when I need them in my code. These are useful for compactly storing multiple values in a single
7

variable that can be referred to later. It also makes it so I can reference all of them much more
efficiently than if they were individual variables by making a FOR x in Leaderboard loop.
Variable
allStats

Data Structure
Array of integers

Leaderboard

Python Dictionary

Example/s
[16, 4, 0, 42, 32, 79]

{Placement:1, Name:"Zane",
Score:1234}
Also, I have a leaderboard.txt file to store the Leaderboard Python dictionary because they need to
remain permanently stored after players have closed the game, and available for the next player to
see.

(CASE tools)
ͳǤ 

8

ʹǤ

 

INPUT
Click HELP or
SETTINGS buttons.
Click on the volume
slider

PROCESS
Find out which screen correlates to the button
pressed.
Calculate the percentage of the slider that the
circle has been dragged to. Alter the game’s
volume to match that percentage.

Change colour blind
mode to
Deuteranopia

Realise which colour blind mode has been
selected and which visual filter corresponds to it.
Select that filter.

Click on MEDIUM

Change the difficulty variable from Easy (the
default) to Medium, which changes the .txt file
that sentences are pulled from for the game from
one with easier sentences to one with more
difficult ones.
Display the racing scene. Check the difficulty
selected to determine the speed of the other cars
and difficulty of sentences. Display a random
sentence from [difficultySelected].txt.
For each letter typed, check if they match the
letter of the sentence displayed. If they do, display
that letter in the text box and change the colour
of that letter in the text at top to green and
increment correctLetters and totalLettersTyped. If
they don’t shake the screen and increment
incorrectLetters by one. If a space proceeds the
letter, increment totalWordsTyped by one.
After enter is hit, increment totalSentencesTyped
by one. When it reaches 10, display the car going
over the finish line. Calculate the wordsPerMinute
by dividing totalWordsTyped by timeTaken/60.
Calculate the accuracy by dividing correctLetters
by totalLettersTyped and multiplying by 100. Stop
incrementing totalTimeTaken by one every
second.

Click on START or
PLAY AGAIN

Letters are typed
during the game

The tenth sentence is
finished being typed.

PLAY AGAIN is
clicked.

Reset correctLetters, totalLettersTyped,
incorrectLetters, totalWordsTyped,
totalSentencesTyped, totalTimeTaken, and other
similar variables to either 0, False, or their original
value. Display the racing scene. Check the
difficulty selected to determine the speed of the
other cars and difficulty of sentences. Display a
random sentence from [difficultySelected].txt.

OUTPUT
Display the help or
settings screen.
Change the position
of the circle on the
volume slider, and
change the volume
of SFX
Apply a visual filter
to make it easier for
people with
deuteranopia to
distinguish colours.
Unhighlight the
EASY button and
highlight the
MEDIUM button
Display the main
game, the cars, and
a sentence to type.
For a correct letter:
The colour of that
letter in the
sentence changes
from black to green,
and that letter
appears in the text
box.
Display the car
reaching the finish
line and show the
user’s score, along
with their words per
minute, accuracy,
time taken, and the
following buttons:
SETTINGS, PLAY
AGAIN, HOME, and
QUIT
Display the main
game, the cars, and
a sentence to type.

9

QUIT is clicked

Run the pygame.quit() function.

Close the
application.

͵Ǥ 

ͶǤ  
Circle = Process, Rectangle = External Entity, Rhombus = Data Store

10

ͷǤ

  


I have developed a very limited prototype, and just tested the basics of some of the functions of my
game, such as how to calculate the statistics for accuracy, wpm, and time taken, and how to let the
player choose the difficulty and how that changes the sentences they need to type. See below for a
sample of the code, as well as the console that shows the user being able to select a difficulty, and a
random sentence from the matching difficulty’s text file being displayed.

11

Above is a prototype of the main menu with buttons that are interacted with when hovered over
and take the player to a different menu when clicked. 10/5/22
I have also developed a prototype

  
My typing game will only be accessible to those that have a computer with an internet connection to
download it. Only about 91% of Australian households with children have a computer in them, and
12

86% of them have internet access, so the game will unfortunately not be available for the
approximate 22% who don’t have both.
People playing this game for the first time might not know how to start or play despite the intuitive
design, so I will have a Help menu that players can click on to receive instructions. These will be clear
enough so that anyone can understand how to play independent of age or computer experience.
I will ensure that any sprites, sounds, or code that I find online are copyright free to avoid any issues
regarding that. Additionally, I will write as much code as I am able, and possibly create some sprites
myself, both of which will circumvent copyright infringement.
Another possible issue is that I am directing people how they should type, which is slightly restrictive.
Especially because this game is designed for children and people new to typing, my game may
influence them into thinking that speed is more important than accuracy, where a good typist should
be able to have a balance of both. Also, I can’t claim that it will improve people’s typing skills like I
had originally planned, because it is not guaranteed and misleading. Instead, I will have to use high
modality language such as “highly likely” when referring to the expected outcomes for users.


 (Consistent, accessible, user-friendly design)
My game’s interface will be clean and intuitive to use; there will be little on the screen besides what
needs to be there and the buttons will all be clear and interactive. When the player hovers their
mouse over a button, it will slightly change position and colour to let players know that it can be
clicked. See below for
sketches of the interface
design for Typing Racers.

13

 (OS and programming language)
My game will be coded in Python using PyCharm as the IDE with Pygame as an interpreter. While it is
being coded on a Windows laptop, it will be accessible for Windows, MacOS, and Linux (as they are
supported by PyCharm). I have chosen to use PyCharm because I have used it before and it is very
easy to use. Additionally, due to its popularity there is a large amount of support online so if I need
help at any point, I should be able to find sufficient resources. I will be using Python 3.7 simply
because I have prior background information on the language and it will be easier to code in a
known language than trying to learn one whilst making the game. Additionally, I have it available on
my computer and have some prior knowledge of PyCharm, which uses python.

 
Windows, Apple, and many other laptops will be able to run my game as long as they can have
PyCharm installed. I may later export the game as an .exe file which would require a windows
computer or emulator to run.

 (Initial)
Note: There is no validation for any variable because the user never has the opportunity to freely
change any variable, only choose between set ones.
Data ID
gameState

Type
String

Format
“stringName”

Description
The name of each game state
to determine what part of the
game is happening

ScreenWidth Integer

NUMBER

bg

Integers

Array of integers

difficulty

String

“stringName”

Character

String

“stringName”

character

String

“Spritesheet
name.png”

This determines the width of
the screen. The higher the
value, the wider the screen
This sets the colour of the
background as an RGB code
The settingsScreen subroutine
changes the computer’s
difficulty based on this value.
The characterSelector
subroutine in the
mainGame.py module
determines which spritesheet
to use as the character based
on this value.
This loads the spritesheet
based on which character was
chosen.

blobx

Integer

NUMBER

results

Python
Dictionary

title

String

Determines the x coordinate
of the character on the
screen.
{Time:INTEGER,
Stores the results of the
Accuracy:INTEGER, player’s game.
WPM:INTEGER}
“stringName”
Determines the title of the

Example/s
“mainGame” or
“menuScreen” or
“settingsScreen”
or “homeScreen”
1350

(150, 200, 255)
“easy” or
“medium” or
“hard”
“blue” or
“orange” or “red”
or “goomba” or
“AmongBlob” or
“pacman”
“BobDaBlob
SpriteSheet.png”
or
“OrangeBlob.png”
20

{Time:27,
Accuracy:65,
WPM:54}
“Typing Racers”
14

window when the game is
open.

 
Due to the nature of a typing game, there will not be restrictions on what characters can be inputted
into the game. This means that users are free to type numbers, non-English characters, and emojis,
however this will subtract from their accuracy. To prevent users from inputting incorrect data types
in the settings, there will be radio buttons or drop-down boxes to select settings rather than a text
box. This will prevent users from accidentally typing a setting incorrectly and will make it easier to
customise the game the way they desire.


x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x

AmongBlob.png: The Among Us secret character spritesheet
AmongUs.png: The icon for my game
background.jpeg: The background image
BadDaBlobSpriteSheet.png: The spritesheet for the computer character
BobDaBlobSpriteSheet.png: The spritesheet for my character
Goomba.png: The Goomba secret character spritesheet
Leaderboard.json: The (unfinished) module to allow leaderboard
functionality
Leaderboard.txt: The text file that contains leaderboard statistics
main.py: The main python file
mainGame.py: The file with the typing game
OrangeBlob.png: The spritesheet for the orange blob character
Pacman.png: The spritesheet for the secret character Pacman
parallaxBackground_NUMBER.png: The different layers to the parallax background
RedBlob.png: The spritesheet for the Red Blob character
restart.jpeg: The restart button image
road_scrolling.mov: Video of a road scrolling that was used as a background in multipls tests
RobusFont.oft: Robus font file
Spritesheet.py: The code for animating spritesheets
Texts.txt: The file with sentences to be typed out
Ubuntu-Regular.ttf: Ubuntu font file

  
I have used Python data dictionaries and .txt files to store and record data in Typing Racers. Texts.txt
is a file that contains all words/sentences that the game can give users to type. Each one is
separated by a new line to make it easy for the code to differentiate and select each word/sentence
(See below).
word
letters

15

typing
game
zane
software
design
development
racing
bob the blob

Leaderboard.txt is a text file containing the following leaderboard information (in the form of a
Python dictionary to make it easy to refer to and call each piece of information):
{Placement:1, Name:"Zane", Score:1234}
{Placement:2, Name:"Alex", Score:123}
{Placement:3, Name:"Jet", Score:12}
{Placement:4, Name:"Sam", Score:1}

It was originally going to be functional within Typing Racers (after the suggestion from Mr Fryer, a
potential user) but ultimately was too time consuming during a time period when I had to study for
trials and prepare multiple major projects for different subjects and it was unfortunately lower on
the priority list than other aspects of the game.

Ȃ   ǣ
(Uses modular structure with appropriate control structures. Inclusion of standard
or common routines)
BEGIN homeScreen:
SetscreenSize to 1350 x 800
Fill background with the colour (150, 200, 255)
Display “Typing Racers” at top middle of screen with font = Robus
and fontSize = 256 and fontColour = (0, 0, 80)
Display “Start” at bottom left of screen with font = Robus and
fontSize = 100 and font colour = (0, 0, 80)
IF mouseHover on “Start” = True:
Lower “Start” by y = 5 and fontColour = (80, 0, 80)
ENDIF
IF mouseClick on “Start” = True:
Begin mainGame
ENDIF
END
BEGIN mainGame:
SetscreenSize to 1350 x 800
Fill background with the colour (150, 200, 255)
Begin race
Begin statistics
Display blue rectangle in the middle of the screen
OPEN Sentences.txt
Display random sentence from Sentences.txt
Close Sentences.txt
IF input = Enter:
BEGIN calculations
Display WPM, accuracy, timeTaken
Display restartButton
IF mouseClick on restartButton = True:
Begin restartGame
ENDIF
ENDIF

16

END
BEGIN statistics:
WPM, accuracy, timeTaken = 0
IF input = spaceBar:
Increment totalWords
ENDIF
FOR letter in sentence:
IF letter = correct:
Increment correctLetters
ENDIF
Increment totalLetters
ENDFOR
startTime = current time (in seconds)
IF input = Enter:
endTime = current time (in seconds)
END
BEGIN calculations:
WPM = 60 * totalWords / (endTime – startTime)
accuracy = 100 * correctLetters / totalLetters
timeTaken = endTime - startTime
END
BEGIN restartGame:
WPM, accuracy, timeTaken = 0
correctLetters, totalLetters, startTime, endTime
Begin mainGame
END

= 0

In the homeScreen routine, features such as the screen dimensions, colour, font sizes and colours,
and the title of the game window are set. It also checks for when the player hovers their mouse over
the Start button. If they do, the start button will slightly change colour and position to show that it
can be interacted with. If clicked on, the mainGame routine is called.
The mainGame routine sets the screen dimensions and background colour before calling the race
and statistics routines. It displays a textbox and a random sentence from Sentences.txt. Once the
player submits their answer by hitting Enter, the Calculations routine is called and the results are
displayed on the screen along with an option to restart the game. If the restartButton is clicked, the
restartGame subroutine begins.
The statistics routine records statistics when the user is playing the game such as how many words
they type (incremented every time they press the spacebar), the number of correct letters and total
letters typed, and the start and end time of their gameplay. This information is sent to the
calculations routine which then calculates the words per minute, accuracy and time taken (see
pseudocode for how each is done).
The restartGame routine resets most variables, then calls the mainGame routine.

17

Below is a structure chart for Typing Racers. Note: there may be differences between the structure
chart and pseudocode as the pseudocode was written much earlier in the development process and
the structure chart is a diagram for the final game.


Throughout this project I have used module testing to ensure each module works as intended. I have
used stubs to make sure that the main part of each module works, and I have used drivers to make
sure each module is called at the correct time. After each big progress update, I tested the program,
and when the game was finished I tested the whole system. I also have had my target audience do
acceptance testing after each big milestone of code to ensure everything they want in the game was
there. I used load test data to make sure that everything works and have use stress tests to help
understand the maximum limits of my game and ensure it will not crash when played.

  
I have been continuously showing my game to users after each big module was added. I asked them
for their opinions on what was added and what they thought I should add next. These users included
Mr Fryer, some peers, my friend’s younger brother, and my younger cousins. Some of their feedback
led to me implementing features into the game such as a leaderboard, different difficulties and
secret characters, and helped me to change already coded features to better suit their requirements.
These mainly focused on aesthetics such as the positioning and size of text and the racers, but also
helped to change a key feature from having to type out sentences to instead having to type
individual words at a time to additionally test the user’s reflexes on quickly responding to the word
appearing and make the game more engaging.

18


I used multiple Computer Aided Software Engineering (CASE) tools to help manage this project and
document my design. The predominantly used one was Google Sheets, as Jet had shared a file with
everyone in the class to help track our progress of the report (see below). I used it to check off each
section of the report when I partially or fully completed it, and it helped to keep track of what task
was next to complete as well as approximately how many words I had left to write using a word to
mark ratio.

I used Excel to make the Gantt chart and I used Lucidchart to make the dataflow diagram and
structure chart seen earlier in this report.



My project used 4 external modules: pygame, sys, time and random. The pygame module was used
throughout the entirety of my code; it was essential for my game to function and made it easy to
create a screen for my game as well as certain objects on the screen. The sys module was used
mainly to try to fix an error with circular imports. The time module was used for the calculations for
the results; it found the start and end time and deduced the total number of seconds taken as well
as the words per minute. The random module was used to take a random word/sentence from the
texts.txt file for the user to type as well as to make the computer player move a random amount
forwards to make its movements seem more realistic to a human rather than it just constantly
moving forwards a set distance.
CASE tools were used to document my design; these were Jet’s Google Sheets and LucidCharts which
have been mentioned above in more detail.

19

Typing Racers does not include linear or binary searches, or bubble/insertion/selection sorts,
however it does contain some standard algorithms such as reading from a (texts.txt) file, and would
have included writing to a (leaderboard.txt) file if I had implemented the leaderboards system.

 (Final)
Data ID
gameState

Type
String

Format
“stringName”

ScreenWidth

Integer

NUMBER

bg

Integers

Array of integers

difficulty

String

“stringName”

Character

String

“stringName”

character

String

“Spritesheet
name.png”

blobx

Integer

NUMBER

results

title

Python
{Time:INTEGER,
Dictionary Accuracy:
INTEGER,
WPM:INTEGER}
String
“stringName”

scroll

Integer

NUMER

x, y

Array of
Integers

NUMBER,
NUMBER

Description
The name of each
game state to
determine what part
of the game is
happening.
This determines the
width of the screen.
The higher the value,
the wider the screen.
This sets the colour of
the background as an
RGB code.
The settingsScreen
subroutine changes
the computer’s
difficulty based on
this value.
The characterSelector
subroutine in the
mainGame.py
module determines
which spritesheet to
use as the character
based on this value.
This loads the
spritesheet based on
which character was
chosen.
Determines the x
coordinate of the
character on the
screen.
Stores the results of
the player’s game.

Determines the title
of the window when
the game is open.
Controls how many
pixels each layer of
the parallax
background scrolls.
These the x and y
coordinates that the

Example/s
“mainGame” or
“menuScreen” or
“settingsScreen” or
“homeScreen”
1350

(150, 200, 255)

“easy” or “medium”
or “hard”

“blue” or “orange” or
“red” or “goomba” or
“AmongBlob” or
“pacman”

“BobDaBlob
SpriteSheet.png” or
“OrangeBlob.png”
20

{Time:27,
Accuracy:65,
WPM:54}
“Typing Racers”

1

200, 130
20

character will start at.
This counter goes up
each time the user
clicks on a character
selection. After it
reaches 2, secret
characters are
revealed.
“StringName”
This string
determines what
screen the game
needs to display.
pygame.font.Font This sets up the font
(‘FontName',
and size of the text.
FontSize)
“StringName”
This is the text that is
displayed in the help
menu.

secretCounter

Integer

NUMBER

state

String

font50

Object

helpText

String

frame

Integer

NUMBER

colour

Integers

Array of integers

FPS

Integer

NUMBER

DifficultyA

Integer

NUMBER

DifficultyB

Integer

NUMBER

totalSentences

Integer

NUMBER

winMSG

String

“StringName”

This determines
which image on the
spritesheet correlates
to which frame.
This sets the colour
(as an RGB code) for
the spritesheets that
should become
transparent.
This is the maximum
number of updates
per second that can
be run.
This is the minimum
distance the
computer character
can move forward
with each button
press for the set
difficulty.
This is the maximum
distance the
computer character
can move forward
with each button
press for the set
difficulty.
This records the total
number of times the
player submits a
word/sentence
This displays the end

0

“homeScreen” or
“settingsScreen” or
“mainGame”
pygame.font.Font
('RobusFont.otf', 50)
“Type the word
displayed to move
Bob Da Blob
forwards”
2

(1, 1, 1)

60

10

20

3

“You win!”
21

timeArray

Array of
floating
points

[NUMBER,
NUMBER,
NUMBER]

WPM

Floating
Point

NUMBER

start_time

Floating
point

NUMBER

total_time

Floating
point

NUMBER

Accuracy

Floating
point

NUMBER

bg_images

Array of
strings

[“String”,
“String”, String”]

totalLettersRight

Integer

NUMBER

totalLettersWrong Integer

NUMBER

message depending
on if the player wins,
draws, or loses
The time array stores
the total time (1d.p.)
taken for each word
to be typed.
This is the number of
words per minute
(1d.p.) the player
typed.
Records the universal
time that the player
started typing at
Records the
difference in time
since the player
started and finished
typing
Records the ratio of
correct to total letters
typed
Contains the different
background image
file names for the
parallax scrolling.
Keeps track of how
many correct letters
the player types
Keeps track of how
many incorrect
letters the player
types

[1.7, 3.4, 2.3, 4.0]

72.4

12421233121.2

7.3

79.8

[“bg_image1.png”,
“bg_image2.png”,
“bg_image3.png”]
132

24


Because my project is relatively small, it was not worth creating a program to complete automated
testing for me and it was simpler to just manually test the code myself. Although it is less reliable as
there could be human error involved leading to incorrect buttons being pressed, it was very quick
most of the time to run my code and check if it worked as intended, and if I did accidentally press a
wrong button, it was fast to close the program and retest.
Whenever I finished implementing a section of Typing Racers, I would back up the code before
beginning the next section to avoid losing any progress. I did this both on my computer’s hard drive
and an external USB. Often, I would even back it up when I was only partially through completing a
section because it allowed me to experiment with the code to see what could be a good path
forward, and either continue with that code or revert to my backup if I decided there was a better
alternative. I often used my backups when I failed to correctly implement parts of my code, a
primary example being with the screen scrolling feature. From looking at the backups below, it is
22

clear that many mistakes were made with it from 15/5/22 to 25/5/22 and these backups were
extremely useful to be able to go back to code that works after altering it so much trying to get the
parallax background to scroll correctly that it no longer let the game run.


Whilst working on implementing my software solution, I used a variety of testing techniques to
ensure it was working as intended. Whenever I finished an algorithm or small portion of code I
would complete a unit test to check it worked. This often included inputting test data that contained
normal, erroneous, and boundary values and adding temporary print statements to check what
values certain variables held along the way. I also tested whole subroutines at a time to ensure they
each worked. Finally, I completed program tests and system tests to test the programs and system
as a whole respectively.
I used stubs throughout the creation of Typing Racers. An example of this is when I had the character
selection screen without having different characters made yet. I tested its functionality by making it
print a statement with the character chosen.
I used drivers to test multiple subroutines that required other parts of the code that had not been
written yet. For example, I had written the code to have different difficulties in the game before
implementing the option to actually change the difficulty, so I tested that the computer player
moved faster on the Hard difficulty by manually setting the difficulty variable to hard in the code.
Because there are not many places within the game for users to input their own data (they are
mainly presented with options that they must choose between e.g. difficulty selector, character
selector) there was not a need for too much live test data. Despite this, I still did complete live tests
for the game, namely the text box which allows anything to be typed into. Because the program
checks if every input is identical to the word/sentence the game provides, no matter what the user
types (whether it’s a letter, symbol, emoji, or anything else) will either provide a result of being
identical or not being identical to the correct letter. I tested the limits of my system by continuously
typing into the single text box for over two minutes before submitting my answer, and the game still
23

worked perfectly normally and provided me with the correct total time, a very low WPM, and a very
low accuracy.

 
See the appendices for full code of all .py files with comments (internal documentation) included.

 
My game provides a help button on the home screen so anyone playing for the first time can
instantly see it and check for help.

Clicking on the help button presents users with the following help screen:

24

This is sufficient help for players to understand the objective of the game and additionally point
them in the direction of how to play as secret characters. There is a back button to return to the
previous page.

   
Throughout the process of making Typing Racers, I continuously communicated with possible users
including Mr Fryer, classmates, friends, and my younger cousins. For their inputs and opinions, see
the appendices for my logbook which contains information from meetings, texts, and surveys with
potential users.



At the beginning of this project, I sent a survey to potential users and talked to friends to determine
the following requirements for Typing Racers:
1.
2.
3.
4.
5.

Must give users messages to type.
Must record and display the accuracy of the user’s response.
Must record and display the words per minute typed by the user.
Must look visually appealing.
Must have some sort of game aspect to make it entertaining (e.g. rewards system, racing
game, having a storyline)
6. Must be varied enough that you can play it multiple times and not get bored.

I personally believed that all user requirements were met, but I wanted to guarantee they were by
asking some potential users what their opinions were. I asked five people (peers and classmates) and
after playing the completed version of Typing Racers, all five of them stated that all six user
requirements had been successfully met.

 
My feedback from potential users over the course of the project has been predominantly positive
and vastly beneficial to the production of Typing Racers. They have provided me with ideas and
criticism that I alone would not have thought of and have helped me improve the game as the
project progressed.
At the very beginning of this major project, I defined the problem to be:
“Children who are first having access to computers often find it challenging to type quickly and can
often teach themselves to type with one finger at a time, which is very slow and will be detrimental
for their future. Typing tutorials online can be very boring and not motivating for young children and
they can lose interest quickly, so they don’t learn the skill to type quickly with all fingers which can
be vital for their future.”
In my opinion, the game:
-

Is aimed for younger children who are often (new to)/(bad at) typing
Encourages users to type faster
25

-

Is entertaining and motivating both for the target audience of young children but also for
teenagers

However, I wanted to ensure that it was not bias that led to my conclusion that Typing Racers was a
good solution to the problem, so I let five potential users play the final version of the game and all
five of them stated that they believed the game was a good solution to the problem. One stated
“This is the greatest typing game I have ever played… Yes of course it’s the perfect solution to your
problem”.

   
Ease of Use: After letting some peers test my original game, they informed me of some ways to
make the game easier to play and more intuitive to use. I did not use to have a home screen for
Typing Racers and instead when the game was run the player was immediately thrown into the
gameplay. The overall feedback received was that players were unsure exactly what to do but could
figure it out with little help. However, I decided that this was insufficient and made a home screen
that allowed players to click a Help button that would inform them of what their goal was and how
to play, and a Play button so they could choose when they were ready to start. Additionally, a user
commented on how they did not like how static the menu felt, so I added animations to the buttons
so they changed colour, size and position when hovered over to feel more user-friendly.
Security: Although there were never any security issues with my game in the first place, I did
encounter one when planning how the leaderboard system would work. I had originally planned for
players to be able to save their score by inputting their name which would accompany their number
of points and placement on the leaderboard. However, because this game is made for children I
wanted to ensure that all names were kept private and that there were no inappropriate names. My
solution to this was to limit the inputted name to three characters. This would allow users to enter
their initials (First, Middle, Last) or any three letters to represent their name. It also made it easier to
prevent inappropriate words from being typed because there are a limited amount of them that are
three letters long and I could have made a list of words that were not allowed to be used as names.
Unfortunately, the leaderboard idea never made it into the final game due to time constraints and
its overall insignificance on the functionality of the game and its ability to meet the user
requirements / be a solution to the defined problem.
Inclusivity: I wanted my game to be inclusive to everyone who meets the requirements to play the
game (i.e. they have a computer that meets the minimum requirements noted in the Requirements
section of this document, and they are physically able to type) so I made two changed from my
original design. The first is that not everyone is at the same level of typing ability, and some may find
it more difficult to type than others. I wanted everyone – no matter their ability – to be able to play
Typing Racers, so I added multiple difficulties (Easy, Medium, Hard) so that users can choose how
difficult or easy they want the computer character to be. Additionally, after showing my product to a
friend who is colourblind (Ethan Liu), I was informed that the colours for the computer character and
the playable character were quite similar and took him a second to differentiate who was who. I
fixed this issue in two ways: I changed the appearance of the computer character’s eye and mouth
to make it look mad, and I also added different characters – each a different colour (Red, Orange,
Blue) – as well as secret characters with entirely different appearances to the computer character so
that everyone is able to tell them apart.
26

Interface Design: I unfortunately do not have any images of the original interface design because it
was changed before the earliest backup of Typing Racers, but it used to have a light-coloured
background image with white coloured text in front that was hard to read. The text was in a boring
font and too small and close to other text. I showed it to a potential user who gave me feedback that
caused me to significantly change the interface design. Although it was just a temporary menu
screen, they helped me choose:
-

The colour of the background and text to be different shades of blue that do not blend into
each other, so the text is easy to read
The font of text to be more visually appealing
The size and positioning of the text that they thought looked appropriate
The animation of the buttons so they change colour and position when hovered over to
make it feel less static

I have acknowledged all sources used in the appendices.

 
  ȋ͹Ȍ
Atlassian. (2019, May 15). The different types of testing in software.
https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing
Replit. (2020, October 3). Typing game in Python!!!!! replit. https://replit.com/talk/share/TYPINGGAME-IN-PYTHON/56272
Rahul, B. (2022, March 22). Python Project on Typing Speed Test – Build your first game in Python.
https://techvidvan.com/tutorials/project-in-python-typing-speed-test/

 
https://docs.google.com/document/d/1ipwKe9Dv6v0RpfhO6MNELZDzpaW7uC5xIQbH12C84A/edit?usp=sharing


https://docs.google.com/forms/d/1erCgtXbIUSgog6N_LVEmt5US6xtf6cIAxpPwtE5ZuM/edit?usp=sharing
RESULTS FROM SURVEY:

27

28

29

 
Main.py
import pygame, spritesheet, sys, time, random, mainGame, json
from threading import Thread
pygame.init()
pygame.mixer.init()
global clock
clock = pygame.time.Clock()
scroll = 1
# create the screen
screenWidth = 1350
screenHeight = 800
bgblue = (202, 228, 241)
bg = (150, 200, 255)
black = (1, 1, 1)
screen = pygame.display.set_mode((screenWidth, screenHeight))
x, y = 200, 130
difficulty = "medium"
character = "blue"
secretCounter = 0
class Button():
def __init__(self, x, y, image):
self.image = image
self.rect = self.image.get_rect()
self.rect.topleft = (x, y)
class GameState():
def __init__(self):
self.state = "homeScreen"
def homeScreen(self):
screen = pygame.display.set_mode((screenWidth, screenHeight))
screen.fill(bg)
pygame.display.set_caption("Typing Racers Menu")
pygame.display.set_icon(amongUsIcon)
# All text
font256 = pygame.font.Font('RobusFont.otf', 256)
font100 = pygame.font.Font('RobusFont.otf', 100)
font110 = pygame.font.Font('RobusFont.otf', 110)
# Creating the logo
logoText = font256.render("Typing Racers", True, (0, 0, 80), bg)
logoTextRect = logoText.get_rect()
logoTextRect.center = (screenWidth // 2, screenHeight // 13)
screen.blit(logoText, logoTextRect)
# Creating Button Functionality
pos = pygame.mouse.get_pos()
# Creating the buttons
startText = font100.render("Start", True, (0, 0, 80), bg)
startTextRect = startText.get_rect()
startTextRect.center = (675, 300)
startButtonImage = screen.blit(startText, startTextRect)

30

if startButtonImage.collidepoint(pos):
if pygame.mouse.get_pressed()[0] == 0:
startText = font110.render("Start", True, (80, 0, 80), bg)
startTextRect.center = (675, 300)
startButtonImage = screen.blit(startText, startTextRect)
elif pygame.mouse.get_pressed()[0] == 1:
self.state = "mainGame"
settingsText = font100.render("Settings", True, (0, 0, 80), bg)
settingsTextRect = settingsText.get_rect()
settingsTextRect.center = (675, 450)
settingsButtonImage = screen.blit(settingsText, settingsTextRect)
if settingsButtonImage.collidepoint(pos):
if pygame.mouse.get_pressed()[0] == 0:
settingsText = font110.render("Settings", True, (80, 0, 80),
bg)
settingsTextRect.center = (675, 450)
settingsButtonImage = screen.blit(settingsText,
settingsTextRect)
elif pygame.mouse.get_pressed()[0] == 1:
self.state = "settingsScreen"
helpText = font100.render("Help", True, (0, 0, 80), bg)
helpTextRect = helpText.get_rect()
helpTextRect.center = (675, 600)
helpButtonImage = screen.blit(helpText, helpTextRect)
if helpButtonImage.collidepoint(pos):
if pygame.mouse.get_pressed()[0] == 0:
helpText = font110.render("Help", True, (80, 0, 80), bg)
helpTextRect.center = (675, 600)
helpButtonImage = screen.blit(helpText, helpTextRect)
elif pygame.mouse.get_pressed()[0] == 1:
self.state = "helpScreen"
def helpScreen(self):
screen = pygame.display.set_mode((screenWidth, screenHeight))
screen.fill(bg)
pygame.display.set_caption("Typing Racers Help Screen")
pygame.display.set_icon(amongUsIcon)
font256 = pygame.font.Font('RobusFont.otf', 256)
font110 = pygame.font.Font('RobusFont.otf', 110)
font100 = pygame.font.Font('RobusFont.otf', 100)
font50 = pygame.font.Font('RobusFont.otf', 50)
pos = pygame.mouse.get_pos()
logoText = font256.render("Typing Racers", True, (0, 0, 80), (bg))
logoTextRect = logoText.get_rect()
logoTextRect.center = (screenWidth // 2, screenHeight // 13)
screen.blit(logoText, logoTextRect)
# For the back button:
backText = font100.render("Back", True, (0, 0, 80), (bg))
backTextRect = backText.get_rect()
backTextRect.center = (660, 700)
backButtonImage = screen.blit(backText, backTextRect)
if backButtonImage.collidepoint(pos):
if pygame.mouse.get_pressed()[0] == 0:
backText = font110.render("Back", True, (80, 0, 80), (bg))
backTextRect.center = (650, 700)
backButtonImage = screen.blit(backText, backTextRect)

31

elif pygame.mouse.get_pressed()[0] == 1:
self.state = "homeScreen"
helpText1 = font50.render("Type the word displayed to move Bob da
blob forwards.", True, (0, 0, 80), (bg))
helpTextRect1 = helpText1.get_rect()
helpTextRect1.center = (660, 250)
helpButtonImage1 = screen.blit(helpText1, helpTextRect1)
helpText2 = font50.render("Try to make it to the end before the
evil blob!", True, (0, 0, 80), (bg))
helpTextRect2 = helpText2.get_rect()
helpTextRect2.center = (660, 300)
helpButtonImage2 = screen.blit(helpText2, helpTextRect2)
helpText3 = font50.render("You can change your blob in the settings
menu", True, (0, 0, 80), (bg))
helpTextRect3 = helpText3.get_rect()
helpTextRect3.center = (660, 450)
helpButtonImage3 = screen.blit(helpText3, helpTextRect3)
helpText4 = font50.render("Try clicking on the same character
multiple times for a secret", True, (0, 0, 80), (bg))
helpTextRect4 = helpText4.get_rect()
helpTextRect4.center = (660, 500)
helpButtonImage4 = screen.blit(helpText4, helpTextRect4)
def settingsScreen(self):
global difficulty, character, secretCounter
# Making the scene
screen = pygame.display.set_mode((screenWidth, screenHeight))
screen.fill(bg)
pygame.display.set_caption("Typing Racers Settings Screen")
pygame.display.set_icon(amongUsIcon)
font256 = pygame.font.Font('RobusFont.otf', 256)
font110 = pygame.font.Font('RobusFont.otf', 110)
font100 = pygame.font.Font('RobusFont.otf', 100)
font50 = pygame.font.Font('RobusFont.otf', 50)
font53 = pygame.font.Font('RobusFont.otf', 52)
pos = pygame.mouse.get_pos()
# Making the logo
logoText = font256.render("Typing Racers", True, (0, 0, 80), (bg))
logoTextRect = logoText.get_rect()
logoTextRect.center = (screenWidth // 2, screenHeight // 13)
screen.blit(logoText, logoTextRect)
#Making the secret game
secretText = font50.render("secret", True, (0, 0, 80), bg)
secretTextRect = secretText.get_rect()
secretTextRect.center = (1250, 750)
secretButtonImage = screen.blit(secretText, secretTextRect)
if secretButtonImage.collidepoint(pos):
if pygame.mouse.get_pressed()[0] == 0:
secretText = font53.render("secret", True, (80, 0, 80), bg)
secretTextRect.center = (1250, 750)
secretButtonImage = screen.blit(secretText, secretTextRect)
elif pygame.mouse.get_pressed()[0] == 1:
self.state = "miniTestGame"
# Making the back button
backText = font100.render("Back", True, (0, 0, 80), (bg))
backTextRect = backText.get_rect()

32

backTextRect.center = (660, 700)
backButtonImage = screen.blit(backText, backTextRect)
if backButtonImage.collidepoint(pos):
if pygame.mouse.get_pressed()[0] == 0:
backText = font110.render("Back", True, (80, 0, 80), (bg))
backTextRect.center = (650, 700)
backButtonImage = screen.blit(backText, backTextRect)
elif pygame.mouse.get_pressed()[0] == 1:
self.state = "homeScreen"
# Determining the difficulty and making the difficulty buttons
if difficulty == "easy":
easyText = font100.render("Easy", True, (0, 0, 0), (bg))
else:
easyText = font100.render("Easy", True, (0, 0, 80), (bg))
easyTextRect = easyText.get_rect()
easyTextRect.center = (400, 580)
easyButtonImage = screen.blit(easyText, easyTextRect)
if easyButtonImage.collidepoint(pos):
if pygame.mouse.get_pressed()[0] == 0:
if difficulty == "easy":
easyText = font110.render("Easy", True, (0, 0, 0), (bg))
else:
easyText = font110.render("Easy", True, (80, 0, 80),
(bg))
easyTextRect.center = (400, 580)
easyButtonImage = screen.blit(easyText, easyTextRect)
elif pygame.mouse.get_pressed()[0] == 1:
difficulty = "easy"
#mainGame.Type_Game.difficultySelector(Difficulty="easy")
mainGame.testingSR("easy")
if difficulty == "medium":
mediumText = font100.render("Medium", True, (0, 0, 0), (bg))
else:
mediumText = font100.render("Medium", True, (0, 0, 80), (bg))
mediumTextRect = mediumText.get_rect()
mediumTextRect.center = (660, 580)
mediumButtonImage = screen.blit(mediumText, mediumTextRect)
if mediumButtonImage.collidepoint(pos):
if pygame.mouse.get_pressed()[0] == 0:
if difficulty == "medium":
mediumText = font110.render("Medium", True, (0, 0, 0),
(bg))
else:
mediumText = font110.render("Medium", True, (80, 0, 80),
(bg))
mediumTextRect.center = (650, 580)
mediumButtonImage = screen.blit(mediumText, mediumTextRect)
elif pygame.mouse.get_pressed()[0] == 1:
difficulty = "medium"
#mainGame.Type_Game.difficultySelector("medium")
mainGame.testingSR("medium")
if difficulty == "hard":
hardText = font100.render("Hard", True, (0, 0, 0), (bg))
else:
hardText = font100.render("Hard", True, (0, 0, 80), (bg))
hardTextRect = hardText.get_rect()
hardTextRect.center = (900, 580)

33

hardButtonImage = screen.blit(hardText, hardTextRect)
if hardButtonImage.collidepoint(pos):
if pygame.mouse.get_pressed()[0] == 0:
if difficulty == "hard":
hardText = font110.render("Hard", True, (0, 0, 0), (bg))
else:
hardText = font110.render("Hard", True, (80, 0, 80),
(bg))
hardTextRect.center = (900, 580)
hardButtonImage = screen.blit(hardText, hardTextRect)
elif pygame.mouse.get_pressed()[0] == 1:
difficulty = "hard"
#mainGame.Type_Game.difficultySelector("hard")
mainGame.testingSR("hard")
# Making text
settingsText1 = font100.render("Choose your difficulty:", True, (0,
0, 80), (bg))
settingsTextRect1 = settingsText1.get_rect()
settingsTextRect1.center = (660, 480)
settingsButtonImage1 = screen.blit(settingsText1, settingsTextRect1)
settingsText2 = font100.render("~~~", True, (0, 0, 80), (bg))
settingsTextRect2 = settingsText2.get_rect()
settingsTextRect2.center = (660, 350)
settingsButtonImage2 = screen.blit(settingsText2, settingsTextRect2)
settingsText3 = font100.render("Choose your colour:", True, (0, 0,
80))
settingsTextRect3 = settingsText3.get_rect()
settingsTextRect3.center = (660, 190)
settingsButtonImage3 = screen.blit(settingsText3, settingsTextRect3)
# Character selection. In retrospect, it would have been more
efficient to create a single subroutine for all characters
# and just change the variables for each character. It was easier
to just copy and paste the code at the beginning when I only had 2
characters.
if character == "blue" and secretCounter >= 15:
blueText = font100.render("Mogus", True, (0, 0, 0), (bg))
elif secretCounter >= 15:
blueText = font100.render("Mogus", True, (0, 0, 80), (bg))
elif character == "blue":
blueText = font100.render("Blue", True, (0, 0, 0), (bg))
else:
blueText = font100.render("Blue", True, (0, 0, 80), (bg))
blueTextRect = blueText.get_rect()
blueTextRect.center = (400, 290)
blueButtonImage = screen.blit(blueText, blueTextRect)
if blueButtonImage.collidepoint(pos):
if pygame.mouse.get_pressed()[0] == 0:
if character == "blue" and secretCounter >= 15:
blueText = font110.render("Mogus", True, (0, 0, 0),
(bg))
elif secretCounter >= 15:
blueText = font110.render("Mogus", True, (80, 0, 80),
(bg))
elif character == "blue":
blueText = font110.render("Blue", True, (0, 0, 0), (bg))
else:
blueText = font110.render("Blue", True, (80, 0, 80),
(bg))

34

blueTextRect.center = (400, 290)
blueButtonImage = screen.blit(blueText, blueTextRect)
elif pygame.mouse.get_pressed()[0] == 1:
character = "blue"
secretCounter += 1
mainGame.characterSelector(character)
if secretCounter >= 15:
mainGame.characterSelector("AmongBlob")
if character == "orange" and secretCounter >= 15:
orangeText = font100.render("Goomba", True, (0, 0, 0), (bg))
elif secretCounter >= 15:
orangeText = font100.render("Goomba", True, (0, 0, 80), (bg))
elif character == "orange":
orangeText = font100.render("Orange", True, (0, 0, 0), (bg))
else:
orangeText = font100.render("Orange", True, (0, 0, 80), (bg))
orangeTextRect = orangeText.get_rect()
orangeTextRect.center = (660, 290)
orangeButtonImage = screen.blit(orangeText, orangeTextRect)
if orangeButtonImage.collidepoint(pos):
if pygame.mouse.get_pressed()[0] == 0:
if character == "orange" and secretCounter >= 15:
orangeText = font110.render("Goomba", True, (0, 0, 0),
(bg))
elif secretCounter >= 15:
orangeText = font110.render("Goomba", True, (80, 0, 80),
(bg))
elif character == "orange":
orangeText = font110.render("Orange", True, (0, 0, 0),
(bg))
else:
orangeText = font110.render("Orange", True, (80, 0, 80),
(bg))
orangeTextRect.center = (650, 290)
orangeButtonImage = screen.blit(orangeText, orangeTextRect)
elif pygame.mouse.get_pressed()[0] == 1:
character = "orange"
secretCounter += 1
mainGame.characterSelector(character)
if secretCounter > 15:
mainGame.characterSelector("goomba")
if character == "red" and secretCounter >= 15:
redText = font100.render("Pacman", True, (0, 0, 0), (bg))
elif secretCounter >= 15:
redText = font100.render("Pacman", True, (0, 0, 80), (bg))
elif character == "red":
redText = font100.render("Red", True, (0, 0, 0), (bg))
else:
redText = font100.render("Red", True, (0, 0, 80), (bg))
redTextRect = redText.get_rect()
redTextRect.center = (900, 290)
redButtonImage = screen.blit(redText, redTextRect)
if redButtonImage.collidepoint(pos):
if pygame.mouse.get_pressed()[0] == 0:
if character == "red" and secretCounter >= 15:
redText = font110.render("Pacman", True, (0, 0, 0),
(bg))
elif secretCounter >= 15:
redText = font110.render("Pacman", True, (80, 0, 80),

35

(bg))
elif character == "red":
redText = font110.render("Red", True, (0, 0, 0), (bg))
else:
redText = font110.render("Red", True, (80, 0, 80), (bg))
redTextRect.center = (900, 290)
redButtonImage = screen.blit(redText, redTextRect)
elif pygame.mouse.get_pressed()[0] == 1:
character = "red"
secretCounter += 1
mainGame.characterSelector(character)
if secretCounter > 15:
mainGame.characterSelector("pacman")
def miniTestGame(self):
# This whole subroutine was used as a driver to test the smaller,
completed functions
global currentTime, lastUpdate, frame
screen = pygame.display.set_mode((screenWidth, screenHeight))
screen.fill(bg)
pygame.display.set_caption("Typing Racers Test Game")
pygame.display.set_icon(amongUsIcon)
font256 = pygame.font.Font('RobusFont.otf', 256)
font110 = pygame.font.Font('RobusFont.otf', 110)
font100 = pygame.font.Font('RobusFont.otf', 100)
font50 = pygame.font.Font('RobusFont.otf', 50)
pos = pygame.mouse.get_pos()
# Making the back button
backText = font100.render("Back", True, (0, 0, 80))
backTextRect = backText.get_rect()
backTextRect.center = (660, 700)
backButtonImage = screen.blit(backText, backTextRect)
if backButtonImage.collidepoint(pos):
if pygame.mouse.get_pressed()[0] == 0:
backText = font100.render("Back", True, (80, 0, 80))
backTextRect.center = (660, 700)
backButtonImage = screen.blit(backText, backTextRect)
elif pygame.mouse.get_pressed()[0] == 1:
self.state = "homeScreen"
# update animation
currentTime = pygame.time.get_ticks()
if currentTime - lastUpdate >= animationCooldown:
frame += 1
lastUpdate = currentTime
if frame >= len(animationList):
frame = 0
# show the frame
screen.blit(animationList[frame], (x, y))
POSITION OF THE CHARACTER WHEN SWAPPING SCENES
playerMovement(2)

# THIS REMEMBERS THE

secret2Text = font50.render("secret", True, (0, 0, 80), (bg))
secret2TextRect = secret2Text.get_rect()
secret2TextRect.center = (100, 750)
secret2ButtonImage = screen.blit(secret2Text, secret2TextRect)
if secret2ButtonImage.collidepoint(pos):
if pygame.mouse.get_pressed()[0] == 0:

36

secret2Text = font50.render("secret", True, (80, 0, 80),
(bg))
secret2TextRect.center = (100, 750)
secret2ButtonImage = screen.blit(secret2Text,
secret2TextRect)
elif pygame.mouse.get_pressed()[0] == 1:
self.state = "testBackground"

def testBackground(self):
# This subroutine was used to test the parallax scrolling, which I
only was able to make work in a seperate mini test game.
# This was the stub and the miniTestGame subroutine was the driver.
global x, y, currentTime, lastUpdate, frame
bg_images = []
for i in range(0, 3):
bg_image =
pygame.image.load(f"parallaxBackground_{i}.png").convert_alpha()
bg_images.append(bg_image)
bg_width = bg_images[0].get_width()
for z in range(50):
speed = 10
for i in bg_images:
screen.blit(i, ((z * bg_width) - scroll * speed, 0))
speed += 5
# show the frame
screen.blit(animationList[frame],(x, y))
POSITION OF THE CHARACTER WHEN SWAPPING SCENES
playerMovement(5)

# THIS REMEMBERS THE

font256 = pygame.font.Font('RobusFont.otf', 256)
font110 = pygame.font.Font('RobusFont.otf', 110)
font100 = pygame.font.Font('RobusFont.otf', 100)
pos = pygame.mouse.get_pos()
currentTime = pygame.time.get_ticks()
if currentTime - lastUpdate >= animationCooldown:
frame += 1
lastUpdate = currentTime
if frame >= len(animationList):
frame = 0
# Making the back button
backText = font100.render("Back", True, (0, 0, 80))
backTextRect = backText.get_rect()
backTextRect.center = (660, 700)
backButtonImage = screen.blit(backText, backTextRect)
if backButtonImage.collidepoint(pos):
if pygame.mouse.get_pressed()[0] == 0:
backText = font100.render("Back", True, (80, 0, 80))
backTextRect.center = (660, 700)
backButtonImage = screen.blit(backText, backTextRect)
elif pygame.mouse.get_pressed()[0] == 1:
self.state = "homeScreen"
def mainGame(self):
# This is the subroutine to run the main game

37

mainGame.Type_Game().run()
#mainGame.runManagerThread.start()
# What needs to happen:
# - Have the text game
# - Have the different blobs, with the player's moving faster when
they type a sentence correctly
#
- Adding different speeds of different coloured blobs
(maybe random), have a moving background
# - Have a finish line with stats appearing
#
- Placement in race, wpm, mistakes, accuracy, total words
def stateManager(self):
# This allows the different screens/parts of the game to display
if self.state == "homeScreen":
self.homeScreen()
if self.state == "helpScreen":
self.helpScreen()
if self.state == "settingsScreen":
self.settingsScreen()
if self.state == "miniTestGame":
self.miniTestGame()
if self.state == "mainGame":
self.mainGame()
if self.state == "testBackground":
self.testBackground()
def playerMovement(playerSpeed):
# This moves the blob and changes how fast its animation moves;
# the faster it moves, the faster it blobs up and down
global x, y, animationCooldown
keys = pygame.key.get_pressed()
if keys[pygame.K_LEFT]:
x -= (1 * playerSpeed)
animationCooldown = 200
elif keys[pygame.K_RIGHT]:
x += (1 * playerSpeed)
animationCooldown = 200
elif keys[pygame.K_DOWN]:
y += (1 * playerSpeed)
animationCooldown = 200
elif keys[pygame.K_UP]:
y -= (1 * playerSpeed)
animationCooldown = 200
else:
animationCooldown = 500
gameState = GameState()
bobDaBlobSpriteSheet =
pygame.image.load('BobDaBlobSpriteSheet.png').convert_alpha()
spriteSheet = spritesheet.spriteSheet(bobDaBlobSpriteSheet)
flipped = pygame.transform.flip(bobDaBlobSpriteSheet, True, False)
amongUsIcon = pygame.image.load('AmongUs.png').convert_alpha()
# animation list
animationList = []
animationSteps = 2
lastUpdate = pygame.time.get_ticks()
animationCooldown = 500
frame = 0

38

for x in range(animationSteps):
# (frame, xsize, ysize, scale, background colour removed)
animationList.append(spriteSheet.get_image(x, 16, 16, 7, black))
bg_images = []
for i in range(0, 3):
bg_image =
pygame.image.load(f"parallaxBackground_{i}.png").convert_alpha()
bg_images.append(bg_image)
bg_width = bg_images[0].get_width()

# Below is the loop that allows the game to continue running until closed.
# Additionally, it keeps the background scrolling (but this only works in
the test background subroutine
FPS = 60
run = True
while run:
#f = open('leaderboard.txt', 'r')
#leaderboard = [line.replace('\n', '') for line in f.readlines()]
#print(leaderboard[2])
clock.tick(FPS)
gameState.stateManager()
scroll += 1
if scroll >= 500:
scroll = 1
#mainGame.Type_Game().set_scroll()
for event in pygame.event.get():
if event.type == pygame.QUIT:
run = False
pygame.display.update()

mainGame.py
import pygame
import sys
import time
import random
import importlib
import spritesheet
from threading import Thread
# Initial variables:
background_image = 'background.jpeg'
sentences_file = 'texts.txt'
clock = pygame.time.Clock()
FPS = 600
pygame.init()
global scroll
scroll = 0
difficultyMG = "easy"
variable = "test"
DifficultyA = 20
DifficultyB = 10
character = "BobDaBlobSpriteSheet.png"
def testingSR(d):

39

# This chooses the two speed options for the computer for each
difficulty
global variable, DifficultyA, DifficultyB
variable = d
if variable == "easy":
DifficultyA = 10
DifficultyB = 5
elif variable == "medium":
DifficultyA = 20
DifficultyB = 10
elif variable == "hard":
DifficultyA = 30
DifficultyB = 20
# print(variable)
def characterSelector(z):
# This selects the spritesheet for the selected character
global character
if z == "blue":
character = 'BobDaBlobSpriteSheet.png'
elif z == "orange":
character = "OrangeBlob.png"
elif z == "red":
character = "RedBlob.png"
elif z == "goomba":
character = "Goomba.png"
elif z == "AmongBlob":
character = "AmongBlob.png"
elif z == "pacman":
character = "Pacman.png"
else:
character = 'BobDaBlobSpriteSheet.png'
class Type_Game:
def __init__(self):
pygame.init()
self.colour_heading = (49, 58, 82)
self.colour_text = (235, 230, 232)
self.colour_results = (216, 222, 146)
self.w = 1350
self.h = 800
# Blob animation
self.blobx = 20
self.blobBx = 20
self.bloby = 420
self.blobBy = 620
self.animationList = []
self.animationListB = []
self.animationSteps = 2
self.animationStepsB = 2
self.blobBRand = 0
self.lastUpdate = pygame.time.get_ticks()
self.animationCooldown = 300
self.frame = 0
self.frameB = 0
# Setting up the spritesheet and animation
self.characterSpriteSheet =
pygame.image.load(character).convert_alpha()
self.spriteSheet =

40

spritesheet.spriteSheet(self.characterSpriteSheet)
self.badDaBlobSpriteSheet =
pygame.image.load('BadDaBlobSpriteSheet.png').convert_alpha()
self.spriteSheetB =
spritesheet.spriteSheet(self.badDaBlobSpriteSheet)
for x in range(self.animationSteps):
# (frame, xsize, ysize, scale, background colour removed)
self.animationList.append(self.spriteSheet.get_image(x, 16, 16,
7, (1, 1, 1)))
for x in range(self.animationStepsB):
# (frame, xsize, ysize, scale, background colour removed)
self.animationListB.append(self.spriteSheetB.get_image(x, 16,
16, 7, (1, 1, 1)))
self.screen = pygame.display.set_mode((self.w, self.h))
self.active = True
self.results = "Time:0 ~ Accuracy:0 % ~ Words Per Minute:0"
self.accuracy = "0%"
self.totalLettersRight = 0
self.totalLettersWrong = 0
self.totalLetters = 0
self.reset = True
self.restartButtonVariable = False
pygame.display.set_caption("Typing Game")
# Setting up the parallax background
self.bg_img = pygame.image.load(background_image)
self.bg_img = pygame.transform.scale(self.bg_img, (1350, 800))
self.scroll = 0
self.bg_images = []
self.totalSentences = 0
self.timeArray = []
self.wpm = 0
self.SRtimes = -1
for i in range(0, 3):
self.bg_image =
pygame.image.load(f"parallaxBackground_{i}.png").convert_alpha()
self.bg_images.append(self.bg_image)
self.winMsg = "You broke the game!"
self.totalWordsTyped = 0
self.difficulty = "blank"
def difficultySelector(self, Difficulty):
# This sets the difficulty to the one selected
self.difficulty = Difficulty
# print(self.difficulty)
# The following 3 subroutines set up the fonts
def write_text_UBG(self, screen, title, y, f_size, text_colour):
font_family = pygame.font.Font("Ubuntu-Regular.ttf", f_size)
# text = font_family.render(title, 1, text_colour, (125, 165, 247))
#BACKGROUND BLENDS WITH SKY
text = font_family.render(title, 0, text_colour) # NO BACKGROUND
text_box = text.get_rect(center=(self.w / 2, y))
screen.blit(text, text_box)
def write_text_U(self, screen, title, y, f_size, text_colour):
font_family = pygame.font.Font("Ubuntu-Regular.ttf", f_size)
text = font_family.render(title, 1, text_colour)
text_box = text.get_rect(center=(self.w / 2, y))
screen.blit(text, text_box)

41

def write_text_R(self, screen, title, y, f_size, text_colour):
font_family = pygame.font.Font("RobusFont.otf", f_size)
text = font_family.render(title, 1, text_colour)
text_box = text.get_rect(center=(self.w / 2, y))
screen.blit(text, text_box)
def show_result(self, screen):
# This calculates statistics and displays them to the player after
the race
self.totalLettersWrong = self.totalLetters - self.totalLettersRight
self.accuracy = (100 * self.totalLettersRight) / self.totalLetters
# self.accuracy = (count * 100) / len(self.word)
self.end = True
sumTime = 0.0
for i in range(len(self.timeArray)):
sumTime = sumTime + self.timeArray[i]
if sumTime == 0.0:
sumTime = 0.1 # This is for when the player never hits enter
and just spams letters, which doesn't increase the time, leaving it at 0
which causes a ZeroDivision error on the next line
# self.wpm = (len(self.input_text) * 60) / (5 * sumTime)
self.wpm = (self.totalWordsTyped * 60) / sumTime
self.results = "Time: " + str(round(sumTime, 2)) + " secs ~
Accuracy: " + str(
round(self.accuracy)) + "% ~ WPM: " + str(round(self.wpm))
def get_sentence(self):
# This provides the sentences to type
self.totalSentences += 1
return random.choice(open(sentences_file).read().split('\n'))
def draw_blob(self):
# This subroutine animates and moves the character when the player
types
currentTime = pygame.time.get_ticks()
if currentTime - self.lastUpdate >= self.animationCooldown:
self.frame += 1
self.lastUpdate = currentTime
if self.frame >= len(self.animationList):
self.frame = 0
if not self.restartButtonVariable:
self.screen.blit(self.animationList[self.frame], (self.blobx,
self.bloby))
else:
self.screen.blit(self.animationList[0], (self.blobx,
self.bloby))
if currentTime - self.lastUpdate >= self.animationCooldown:
self.frameB += 1
self.lastUpdate = currentTime
if self.frameB >= len(self.animationListB):
self.frameB = 0
if not self.restartButtonVariable:
self.screen.blit(self.animationListB[self.frame], (self.blobBx,
self.blobBy))
else:
self.screen.blit(self.animationListB[0], (self.blobBx,
self.blobBy))
if not self.end:
count = 0
for i, c in enumerate(self.word):
try:

42

self.totalLetters += 1
if self.input_text[i] == c:
count += 1
self.totalLettersRight += 1
count = 0
except:
self.totalLetters += 1
def draw_bg(self):
# This subroutine controls the background and how its different
layers move
global scroll
# scrollManager(1)
self.screen.fill([0, 0, 0])
for x in range(500):
speed = 1
for i in self.bg_images:
self.screen.blit(i, ((x * 1300) - (scroll * speed), 0))
speed += 1
self.write_text_R(self.screen, "Typing Racers", 80, 72,
self.colour_heading)
self.write_text_U(self.screen, self.word, 200, 24, self.colour_text)
self.draw_blob()
if self.restartButtonVariable:
bg = (150, 200, 255)
pos = pygame.mouse.get_pos()
font256 = pygame.font.Font('RobusFont.otf', 256)
font100 = pygame.font.Font('RobusFont.otf', 100)
font110 = pygame.font.Font('RobusFont.otf', 110)
restartText = font100.render("Restart", True, (200, 80, 50))
restartTextRect = restartText.get_rect()
restartTextRect.center = (450, 710)
restartButtonImage = self.screen.blit(restartText,
restartTextRect)
backText = font100.render("Back", True, (200, 80, 50))
backTextRect = backText.get_rect()
backTextRect.center = (850, 710)
backButtonImage = self.screen.blit(backText, backTextRect)
self.show_result(self.screen)
self.write_text_U(self.screen, self.results, 350, 28,
self.colour_results)
if self.blobx > self.blobBx:
self.winMsg = "You Win!"
winMsgColour = (0, 255, 0)
elif self.blobx < self.blobBx:
self.winMsg = "You Lose!"
winMsgColour = (255, 0, 0)
else:
self.winMsg = "You Tied! (wow, that's rare)"
winMsgColour = (0, 0, 255)
self.write_text_R(self.screen, self.winMsg, 450, 70,
(winMsgColour))
self.end = True
if restartButtonImage.collidepoint(pos):
if pygame.mouse.get_pressed()[0] == 0:
# restartText = font110.render("Restart", True, (0, 0,
80))
# restartTextRect.center = (670, 710)
restartButtonImage = self.screen.blit(restartText,
restartTextRect)

43

elif pygame.mouse.get_pressed()[0] == 1:
self.restart_game()
def restart_game(self):
# This subroutine resets the game
# time.sleep(1)
self.reset = False
self.restartButtonVariable = False
self.end = False
self.input_text = ''
self.word = ''
self.start_time = time.time()
self.total_time = 0
self.wpm = 0
self.word = self.get_sentence()
self.timeArray = []
if not self.word:
self.restart_game()
self.screen.fill((0, 0, 0))
# self.screen.blit(self.bg_img, (0, 0))
pygame.display.set_mode((1350, 800))
self.blobx, self.blobBx = 20, 20
self.draw_bg()
title = "Typing Racers"
self.write_text_R(self.screen, title, 80, 72, self.colour_heading)
# pygame.draw.rect(self.screen, (255, 190, 20), (50, 250, 1250, 50),
2)
# pygame.draw.rect(self.screen, (255, 190, 20), (525, 670, 300,
100), 2)
self.write_text_U(self.screen, self.word, 200, 24, self.colour_text)
def softRestart(self):
# This subroutine partially resets the game. This is done every
time a player finishes typing a word
self.SRtimes += 1
self.reset = False
self.restartButtonVariable = False
self.end = False
self.input_text = ''
self.word = ''
if self.SRtimes > 0:
SRtotalTime = round((time.time() - self.start_time), 2)
self.timeArray.append(SRtotalTime)
# print(self.timeArray)
self.start_time = time.time()
self.total_time = 0
self.word = self.get_sentence()
if not self.word:
self.softRestart()
self.screen.fill((0, 0, 0))
# self.screen.blit(self.bg_img, (0, 0))
pygame.display.set_mode((1350, 800))
self.draw_bg()
title = "Typing Racers"
self.write_text_R(self.screen, title, 80, 72, self.colour_heading)
# pygame.draw.rect(self.screen, (255, 190, 20), (50, 250, 1250, 50),
2)
# pygame.draw.rect(self.screen, (255, 190, 20), (525, 670, 300,
100), 2)
self.write_text_U(self.screen, self.word, 200, 24, self.colour_text)

44

def run(self):
# This subroutine runs the game and accepts inputs from the player
global scroll
# print(self.difficulty)
self.softRestart()
self.running = True
while self.running:
clock = pygame.time.Clock()
pygame.draw.rect(self.screen, self.colour_heading, (50, 250,
1250, 50), 3)
self.write_text_UBG(self.screen, self.input_text, 274, 24, (250,
250, 250))
for event in pygame.event.get():
if event.type == pygame.QUIT:
self.running = False
sys.exit()
elif event.type == pygame.MOUSEBUTTONUP:
x, y = pygame.mouse.get_pos()
if x >= 50 and x <= 1250 and y >= 200 and y <= 300:
# self.active = True
# self.input_text = ''
self.start_time = time.time()
if x >= 320 and x <= 570 and y >= 670 and y <= 770 and
self.end:
self.restart_game()
x, y = pygame.mouse.get_pos()
elif x >= 770 and x <= 950 and y >= 670 and y <= 770
and self.end:
import main
importlib.reload(main)
sys.modules.pop("main")
main.gameState.state = "homeScreen"
elif event.type == pygame.KEYDOWN:
if not self.restartButtonVariable:
self.blobx += 10
self.blobBRand = random.randint(0, 2)
if self.blobBRand == 1:
self.blobBx += DifficultyB
elif self.blobBRand == 2:
self.blobBx += DifficultyA
if self.blobx >= 1200:
self.restartButtonVariable = True
self.draw_bg()
if self.active and not self.end: # LOOK AT THIS LINE,
IT IS NEVER CALLED FOR SOME REASON
if event.key == pygame.K_RETURN:
self.totalWordsTyped += 1
self.softRestart()
self.draw_bg()
# print(self.input_text)
elif event.key == pygame.K_RETURN:
if self.blobx >= 1000:
self.restartButtonVariable = True
self.draw_bg()
# print(self.input_text)
self.show_result(self.screen)
# print(self.results)
self.write_text_U(self.screen, self.results,
350, 28, self.colour_results)
self.end = True

45

elif event.key == pygame.K_BACKSPACE:
self.input_text = self.input_text[:-1]
self.blobx -= 20
else:
try:
self.input_text += event.unicode
scroll += 1
except:
pass
pygame.display.update()

spritesheet.py
import pygame
class spriteSheet():
def __init__(self, image):
self.sheet = image
def get_image(self, frame, width, height, scale, colour):
image = pygame.Surface((width, height)).convert_alpha()
image.blit(self.sheet, (0, 0), (0, (frame * height), width, height))
image = pygame.transform.scale(image, (width * scale, height *
scale))
image.set_colorkey(colour)
return image

46

