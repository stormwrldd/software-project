SDD Project Portfolio
Singleplayer Arena Game with Unity
Alexander Kam 11W

Introduction
During the final weeks of Term 2, the SDD students were given a “mini project task” that involved
creating a unique software solution for a specific problem or need. Having learned the fundamentals
and advanced techniques of Java and gaining an understanding of data storage in text files, each
student embarked on separate tasks based on their personal choices.
Each student was required to create a portfolio to handle the planning of the solution and
documentation of the final software.

Content
1.0. Planning and Understanding
1.1. Project Proposals
1.2. Context Diagram and IPO Chart
1.3. Software Development Approach and Licensing
1.4. Social and Ethical Issues

2.0. Designing and Implementing
2.1. Gantt Chart and Kanban Board
2.2. Storyboard
2.3. System Flowchart
2.4. Data Flow Diagram
2.5. Structure Charts and Pseudocode

3.0. Testing and Error Checking
3.1 Error Prevention
3.2. Data Dictionary
3.3. Whitebox and Blackbox Testing
3.4. Desk Checks

4.0. Final Solution
4.1 Error Prevention
4.2. Data Dictionary

Page No.
3
3-4
5
6-7
8

9
9-10
11
12
13
14-17

18
18-20
21
22-35
36

37
37-58
59-60

1.0. Planning and Understanding
The first step of the task was to identify a problem or need, then plan and understand the software
solution for said problem or need. When first issued the project, I decided to partner up with a peer,
Yuta, in order to develop more demanding programs. With a team of two programmers and significant
experience of coding in Java between us, we decided to create a game that required completely new
skills in order to push ourselves.

1.1. Project Proposals
Original Project Proposal
Names: Alex Kam and Yuta Kataoka
Course: 11SDD2019
Title: Multiplayer Arena Game
Description
An online 2D multiplayer game that allows several players to connect and join a virtual arena where
they engage in combat in a free-for-all style gameplay. Players will be brought to a menu scene,
where they have options to customise their projectiles according to their preferences. They will also
be able to create a name and join a room. These rooms are created by the first host and are used by
subsequent players. Players are randomly spawned in several locations within the arena and use a
mouse and keyboard to navigate and shoot at other players. Health packs can be consumed to gain
health. Players' kills are recorded and the highest 5 are kept in a scoreboard in the main menu.
Development Tools
Unity2D
Scope
This project uses C# and a Game Development IDE. The solution will be difficult and demanding as
it requires personal studying and understanding with little help from mentors or tutors. Currently,
developing the game has been stalled by multiplayer integration but is completely possible given an
appropriate time frame.
Originally, we decided upon a multiplayer system whereby players connect to an online virtual arena.
The methods and servers needed for the multiplayer system were to be provided by a Unity plug-in,
Photon. However, the plug-in was not compatible with the latest version of unity and we were forced to
change our concept.

Updated Project Proposal
Names: Alexander Kam and Yuta Kataoka
Course: 11SDD2019
Title: Singleplayer Arena Game
Description
A single player 2D game whereby a player is forced to survive through waves of enemies in an
arena. Players will initially be brought to a menu screen where they will be able to view an existing
table of highscores, search for highscores, and customise their character in aspects such as:
➔ Character Colour
➔ Player Name
➔ Bullet Speed
➔ Fire Rate
➔ Damage
Once brought to the arena, the player will control their avatar using a mouse and keyboard in
top-down combat. The player will attempt to survive as many waves as possible in an endless
format and their highscore (waves completed) will be added when they die.
Development Tools
Unity2D
Scope
This project uses C# and an unfamiliar Game Development IDE. The solution will be difficult and
demanding as it requires personal studying and understanding with little help from mentors or
tutors. Development of the game will progress as much as our willingness to learn independently,
but is completely possible given an appropriate time frame.
The new project proposal instead changes the multiplayer aspect to a single player one. Since less
time would be required to implement multiplayer functionality, this would allow us to spend more time
on refining the singleplayer gameplay. We decided to do this by adding the ability to customise the
appearance and abilities of the characters, allowing for unique gameplay.

1.2. Context Diagram and IPO Chart

Input

Process

Output

playerSettings
projectileSettings

Customise Player

playerName
playerColour

Mouse Input
Keyboard Input

Process Player Inputs

playerMovement
playerProjectiles

Wave Information

Spawn Waves

Enemies and Bosses

playerName
Wave Information

Add Highscore Entry

playerName
wavesCompleted

Figure 1.2.2: IPO Chart for the entire system
In the context diagram and IPO chart, it is clear that the processes identified must take into account
player input through mouse and keyboard and derive information from two sources; the customisation
options and the wave handlers. All the outputs are interwoven together in certain aspects, such as the
Wave Information used in creating bosses and enemies, as well as creating a highscore entry.

1.3. Software Development Approach and Licensing
Software Development Approach: The Agile Approach
Description
The agile approach uses the agile development life cycle to develop programs. It uses incremental,
iterative work sequences, known as sprints, to respond to the unpredictability of constructing
software. It is a dynamic process that requires constant collaboration and communication between
the developer and the client. The agile development life cycle is:
1. Scope out and prioritise projects
2. Diagram requirements for initial sprint
3. Construction/Iteration
4. Release the iteration into production
5. Reverse to step 3 if needed
6. Production and ongoing support for the software release
7. Retirement
Justification
The agile approach is very suitable for our development as we are unsure of how to effectively use
Unity and code in C#, creating unpredictable circumstances. Having limited experience in other
programming languages outside of Java and the unfamiliarity with the Unity IDE, we will encounter
several hiccups along the way. Thus, many factors will make our development very dynamic, forcing
us to adjust the way we program and plan modules throughout the software’s lifecycle.
The agile approach is also perfect for teams of small developers as it is less formal and expensive
than the structured approach and does not require a large team. With only two developers, we will be
limited in the amount of time and effort we can put into the game, but the agile approach will allow us
to tackle our workflow in organised sprints. This involves the use of:
● Goal planning,
● Module prioritisation,
● and Kanban Boards.
These techniques and tools will allow for quicker and organised development of our designated
modules as we will be able to change our goals and priorities if needed. The Kanban board will keep
our tasks in check and ensure that our sprints are on time.

Licence Chosen: Unity Editor Licence
Description

Figure 1.3.1: Unity Personal description from unity.com
The free version of Unity, called Unity Personal, can be used to create, sell, and share games without
paying royalties or any revenue share. However, the free version of Unity cannot be licensed by a
commercial entity with annual gross funds of USD$100,000 per year. The free version is not intended
for the production of professional games and interactive content, but it can still be used to publish
games on online platforms.
The Unity Personal Edition can be used to create, sell, and share games without paying royalties or
any revenue share. However, the free version of Unity cannot be licensed by a commercial entity with
annual gross funds of USD$100,000 per year. It follows the Unity Editor Licence. In this, Unity grants a
non-exclusive, non-transferable, royalty-free licence for the following:
a) To install and execute the Unity Software (Unity Editor)
b) To distribute the runtime portion of the Unity Software intended for distribution
The Unity Editor Licence also allows your Project Content to be licensed and sold by distributors and
Third Party Service providers. The Unity Software can be governed by separate terms, such as open
source licences.
Justification
The Unity Editor Licence, on its own, is essentially a commercial software licence. It is proprietary,
covered by copyright laws, and does not grant user access to the source code. Reverse engineering
the software is illegal under the terms of service. The reason for this is that the game is not intended
to be modified in the far future as it is a simple project. Our goal is to gain experience creating and
possibly publishing a game on as many platforms as possible. By making the software open source,
we are forced to use another game engine and be restricted in our ability to publish.
Licences such as GNU/GPL or other open source software licences do not apply under the Unity Editor
Licence and cannot be considered for the game.
Source: https://unity3d.com/legal/terms-of-service/software

1.4. Social and Ethical Issues
Developing an Effective User Interface
In order to build a successful game, the user interface must be user friendly, meaning that it is
intuitive, consistent, and easily learnt. This would result in good ergonomics, improving morale and
resulting in higher productivity when using the software. To do this, some ideas must be implemented:
● Consistent placement of buttons
The buttons used to navigate around different screens should be similarly named and similarly
placed. This would allow the user to better navigate around the different screens.
● Using colour appropriately
The colours used should be pleasant and follow a specific theme. This would ensure that the
program is not annoying to look at and can be used for extended periods of time.
● Using fonts appropriately
The fonts used should not be too fancy and should fit the theme. Additionally, they should be used
consistently throughout the game to create a sense of continuity.
● Aligning data elements
The highscore table that will be implemented must be correctly aligned. Other elements, such as
the search should be appropriately spaced to ensure for maximum ergonomics.
Messages to the User
The game will have several messages to the user to communicate interactivity. These include:
● Use of audio and sound effects
Whenever the player interacts with a button, fires their gun, hits an enemy, etc, a sound effect
should play to indicate what has happened.
● Use of text and visual cues
Since there is a wave functionality, the wave number should be shown for a few seconds each
time. The user’s HP and name should be prominent as well. When the user dies, a game over
window will be displayed that communicates the number of waves completed.
Inclusivity
In order to ensure that groups of people are not marginalised, the game should take into account
various cultural, economic, and gender backgrounds. In order to achieve this, the game should:
● Use a mouse and keyboard
Since they are the most commonly used input devices for a personal computer. This would allow
anyone with any experience with a computer to play.
● Be free to play
As it is a small-scale project, the game should not be priced. Thus, publishing it for free on a Third
Party Service would ensure that anyone can play it.
● Not include any racial or gender bias
The game should not be geared towards any specific ethnicity or gender by including slang or
stereotypes. It should be generic and non-discriminatory towards any groups of people who play it.

2.0. Designing and Implementing
2.1. Gantt Chart and Kanban Board

Figure 2.1.2: Kanban Board for Sprint Management

The diagrams above are forms of project management that organises tasks in a horizontal time flow.
The project is essentially split into four organised sprints, following agile software development.
Sprint

Deadline

Tasks

1

Week 2 & 3

To enable player movement, projectiles, and camera movement.

2

Week 4 & 5

To create the menu interface, customisation, and enemy AI and health.

3

Week 6 & 7

To implement waves, highscores, a linear search, and game over.

4

Week 8 & 9

To create a pause interface and add SFX and particles

2.2. Storyboard

2.3. System Flowchart

2.4. Data Flow Diagram

2.5. Structure Charts and Pseudocode

Figure 2.5.1: Structure chart for GameController.cs
GameController.cs
BEGIN GameController
Set colourChoice
Set playerName
Set fireRate
Set bulletSpeed
Set damage
Set wavesComplete
Set addEntry to false
OnAwake()
Set singleton
DontDestroyOnLoad(self)
OnUpdate()
IF(addEntry)
AddHighScoreEntry(wavesCompleted, myName)
addEntry = AddHighScoreEntry.addEntry
GetActiveScene and retrieve buildIndex
IF(buildIndex is menu)
Make cursor visible
Find(“CustomiseMenu”)
IF(CustomiseMenu != null)
SetPlayerChoices()
ENDIF
ENDIF
END GameController

Figure 2.5.2: Structure chart for PlayerController.cs
PlayerController.cs
BEGIN PlayerController
Set speed
Set RigidBody
Set healthAmount
Set maxHealth
Set myName
Set playerColour
Set wavesCompleted
OnStart()
UsePlayerChoices(colourChoice,playerName)
OnUpdate()
FaceMouse(mousePosition)
IF(healthAmount<=0)
Destroy(self)
EndGame()
ENDIF
wavesComplete = SpawnController.wavesCompleted
OnFixedUpdate()
moveInput = Input.GetAxis(Horizontal),Input.GetAxis(Vertical)
Move(moveInput)
END PlayerController

Figure 2.5.3: Structure chart for SpawnController.cs

SpawnController.cs
BEGIN SpawnController
Set nextWave to 0
Set timeBetweenWaves to 5
Set waveCountdown to 0
Set wavesCompleted to 0
Set Waves class to have
name
enemyNum
enemyTransform
bossNum
bossTransform
Rate
Set transform array enemySpawn
Set playerPrefab
Set state
OnStart()
CreatePlayer(playerPrefab)

waveCountdown = timeBetweenWaves
OnUpdate()
IF(state is WAITING)
CheckIfEnemyAlive()
IF(EnemyIsNotAlive)
state = COUNTING
waveCountdown = timeBetweenWaves
IF(Player exceeds set number of waves)
nextWave = -1
Multipler++
print(“Looping…”)
ENDIF
wavesComplete++
nextWave++
IF(wavesComplete is a multiple of 3)
RegenPlayerHP()
ENDIF
return
ELSE
return
ENDIF
IF(waveCountdown <= 0)
IF(state != SPAWNING)
SpawnWave(wave[nextWave], multiplier)
ENDIF
ELSE
CountDown()
ENDIF
END SpawnController

3.0. Testing and Error Checking
3.1 Error Prevention
A common problem that occurs in Unity is the instantiation and destruction of game objects
repeatedly. In particular, the player game object is instantiated into the arena and subsequently
destroyed. Many scripts are reliant on the presence of the player game object and changes when it
disappears. When the script calls for a game object that doesn’t exist, this error occurs:

Figure 3.1.1: Console log for CameraFollow.cs
CameraFollow.cs

EnemyController.cs

. . .

. . .

void FixedUpdate()
{
//Error Prevention
if (player == null)
return;
}

void Update()
{
//Error Prevention
if (playerObject == null)
return;

. . .

. . .

The return function terminates the loop and forces it to restart. This continues on and on until the
player game object is no longer null, allowing for it to be accessed by the script. This ensures that the
object is not being accessed when it is destroyed.

An error may occur when trying to find something that is incorrectly referenced. This can be seen in
the AudioManager script, where the procedure Play() locates an audio file based on the name.
However, if the audio file is incorrectly referenced, an error will appear. To prevent this from happening,
a Debug.LogError() can be used.

AudioManager.cs
//===============PROCEDURE===============//
public void Play(string name)
//Purpose:
To play a specific audio clip
//string name:
Finds the name of the audio
{
Sound s = Array.Find(sounds, sound => sound.name == name);
//Error prevention
if (s == null)
Debug.LogError("Sound was not found, cannot play clip");
else
s.source.Play();
}

Figure 3.1.2: The name “player” is passed to the AudioManager

Figure 3.1.3: The file is called “Player”, not “player”

Figure 3.1.4: The Debug.LogError prints on the console

One error that is almost impossible to happen, but could, is the possibility that the player’s projectile
stats are negative in the PlayerShoot script. This may occur due to the way that they are multiplied in
the CustomisationOptions script when the increment or decrement buttons are clicked. In the event
that they are less than 0, then the game should not run and a Debug.LogError should be used.
PlayerShoot.cs
void Start()
{
if (GameController.GC.fireRate < 0 || GameController.GC.bulletSpeed < 0
|| GameController.GC.damage < 0)
{
Debug.LogError("Player's stats are negative.");
return;
}
else;
{
fireRate = 2 + GameController.GC.fireRate;
velocity = 10 + GameController.GC.bulletSpeed;
damage = 5 + GameController.GC.damage;
}
}

Figure 3.1.5: Damage is multiplied by -10, rather than 10

Figure 3.1.6: Damage is set with the highest points

Figure 3.1.6: Damage is negative and the Debug.LogError is activated

3.2. Data Dictionary
As there are hundreds of variables being used and passed throughout almost 20 scripts, it would be
more appropriate to analyse the data dictionary for the CustomisationOptions script.
Name

Data Type

Data Format

Description

Example
-

CO

Singleton

-

Allows for other scripts to call on
functions and variables from the
local script

nameText

Text

“_____”

Stores the value of the inputText
game object

“Adam”

playerName

String

“_____”

Uses the nameText to store into
a string.

“Adam”

border

GameObject

-

Acts as a black outline when a
button is pressed.

-

player

Image

-

A placeholder player that
changes colour.

-

playerColour

Color[ ]

{ (r,g,b,a),
(r,g,b,a) }

colourChoice

Integer

#

Determines what colour is
chosen in the array.

0

sliders

Slider[ ]

-

An array that holds the slider
game objects and their values.

-

addButtons

GameObject[ ]

-

An array used to deactivate the
plus buttons.

-

maxPoints

Float

#.#

Sets the maximum number of
points that can be used.

10.0

fireRate

Float

#.#

Holds the value for the player’s
projectile’s fire rate.

8.0

bulletSpeed

Float

#.#

Holds the value for the player’s
projectile’s bullet speed.

4.0

damage

Float

#.#

Holds the value for the player’s
projectile’s damage

20.0

sumOfPoints

Float

#.#

Holds the sum of values across
all sliders.

8

An array that holds the colour
options available.

{ 0.5,1,0),
(1,10) }

3.3. Whitebox and Blackbox Testing
Sprint One
Blackbox Testing | Player Movement and Camera Follow

Moving with ‘a’ and ‘d’

Moving with ‘w’ and ‘s’

Pressing ‘a’

Pressing ‘w’

Pressing ‘d’

Pressing ‘s’

Whitebox Testing | Player Movement and Camera Follow
void FixedUpdate()
{
Vector2 moveInput = new Vector2(Input.GetAxis("Horizontal"), Input.GetAxis("Vertical"));
Debug.Log(moveInput);
Move(moveInput);
}

Moving with ‘a’ and ‘d’

Moving with ‘w’ and ‘s’

Pressing ‘a’

Pressing ‘w’

Pressing ‘d’

Pressing ‘s’

Conclusion
From the whitebox and blackbox tests, it can be seen that the user’s input is being directly translated
into movement to the player avatar. This is taken through Input.GetAxis and is used in a Move()
function. The CameraFollow script is also working as seen in the blackbox tests, where the camera
clamps when the player is near the boundary (the left and bottom walls).

Sprint Two
Blackbox Testing | Menu UI and Projectile Customisation

Start button is Pressed

Name is inputted

Blue is chosen

Fire Rate to 3, Bullet Speed to 2, Damage to 5

Play is Pressed

Whitebox Testing | Menu UI and Projectile Customisation
Start button is Pressed

Quit button is Pressed

Setting name to blank

Setting name to Alex

Selecting White

Selecting Blue

Selecting Red

Selecting Purple

Setting Fire Rate to 5

Setting Bullet Speed to 5

Setting Damage to 5

FR to 5, BS to 5, DMG to 0

FR to 0, BS to 5, DMG to 5

FR to 5, BS to 5, DMG to 5

…

…

…

Conclusion
The customisation options are working as intended from the blackbox and whitebox tests. The name
and colours were accurately represented without mistake. The extremes of the max points were
tested by setting various factors to equal 10.

Sprint 3
Blackbox Testing | Wave System
Starting on Wave 1

Wave 3 (1 Boss, 2 Enemies)

After Wave 3 (Regenerated Health to 100%)

Wave 6 (2 bosses, 4 Enemies)

Wave 12 (4 Bosses, 8 Enemies) - Multiplier in Action

Whitebox Testing | Wave System
Wave 1 (2 Enemies)

Wave 3 (1 Boss and 2 Enemies) + Regen

Wave 6 (2 Bosses and 4 Enemies) + Looping

Wave 7 (2 Enemies * 2)

Sprint 4
Blackbox Testing | Pause Menu and Particle Systems
Pressing ‘esc’ to bring up the Pause Menu

Pressing Resume

Pressing Menu

Destroying an Enemy

Destroying a Boss

Whitebox Testing | Pause Menu and Particle Systems
Pressing ‘esc’ to bring up the Pause Menu

Pressing Resume

Pressing Main Menu

Pressing Quit

Destroying an Enemy (Console)

Destroying an Enemy (GameObjects)

Conclusion
In the last spring, the enemy death particles and pause menu were successfully implemented. Whilst
the particles are not too aesthetically pleasing, they work perfectly, with instantiated game objects
appearing for a short period of time where the enemies died. The pause menu works as well, with the
resume, main menu, and quit working as expected. However, the quit function can only be tested when
the game is built.

3.4. Desk Checks
Desk Check for SpawnController.cs
state

EnemyIsAlive

waveCountdown

nextWave

multiplier

COUNTING

-

5

0

1

COUNTING

-

3

0

1

COUNTING

-

0

0

1

SPAWNING

-

0

0

1

SPAWNING

TRUE

0

0

1

WAITING

TRUE

0

0

1

WAITING

FALSE

0

0

1

COUNTING

-

5

1

1

...
SPAWNING

TRUE

0

6

1

WAITING

TRUE

0

6

1

WAITING

FALSE

0

6

1

COUNTING

-

5

0

2

The spawn state cycles from COUNTING to SPAWNING to WAITING. This is entirely controlled on
whether any enemies are alive and whether the countdown has finished. When nextWave goes to 6, it
loops back to 0 and the multiplier increments.
Desk Check for CustomisationOptions.cs
fireRate

bulletSpeed

damage

sumOfPoints

maxPoints

sliders.SetActive()

0

0

0

0

10

TRUE

1

0

0

1

9

TRUE

2

0

0

2

8

TRUE

...
4

2

2

8

2

TRUE

5

2

2

9

1

TRUE

5

3

2

10

0

FALSE

4

3

2

9

1

TRUE

4

3

3

10

0

FALSE

The sliders are set active depending on whether max points is 0 or not. By adjusting the values of
fireRate, bulletSpeed, and damage, the boundaries of the sumOfPoints and maxPoints can be
measured. The desk check shows that the program is working as intended.

4.0. Final Solution
4.1. Full Code Listing
AudioManager.cs
/*
* Author: Alex Kam
* Date: 2-8-19
* Licence: Unity Personal Editor Licence
*/
using UnityEngine.Audio;
using System;
using UnityEngine;
public class AudioManager : MonoBehaviour
{
public static AudioManager AM;

~USE OF RECORDS~
[System.Serializable]
public class Sound
{
public string name;
public AudioClip clip;
[Range(0f, 1f)]
public float volume;
[Range(.1f,3f)]
public float pitch;
[HideInInspector]
public AudioSource source;
}
public Sound[] sounds;
void Awake()
{
if (AudioManager.AM == null)
AudioManager.AM = this;
foreach(Sound s in sounds)
{
s.source = gameObject.AddComponent<AudioSource>();
s.source.clip = s.clip;
s.source.volume = s.volume;
s.source.pitch = s.pitch;
}
}
//===============PROCEDURE===============//
public void Play(string name)
//Purpose:
To play a specific audio clip
//string name:
Finds the name of the audio
{
Sound s = Array.Find(sounds, sound => sound.name == name);
//Error prevention
if (s == null)
Debug.LogError("Sound was not found, cannot play clip");
else
s.source.Play();
}
}

CameraFollow.cs
/*
* Author: Alex Kam
* Date: 2-8-19
* Licence: Unity Personal Editor Licence
*/
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
public class CameraFollow : MonoBehaviour
{
//Singleton
public static CameraFollow CF;
//Player that is being followed
public GameObject playerGO;
public Transform player;
//Zeroing out the velocity
Vector3 velocity = Vector3.zero;
//Time to follow target
public float smoothTime = .15f;
//Enable and set the max Y value
public bool YMaxEnabled = false;
public float YMaxValue = 0f;
//Enable and set the min Y value
public bool YMinEnabled = false;
public float YMinValue = 0f;
//Enable and set the max X value
public bool XMaxEnabled = false;
public float XMaxValue = 0f;
//Enable and set the min X value
public bool XMinEnabled = false;
public float XMinValue = 0f;
void Start()
{
if(playerGO == null)
playerGO = GameObject.FindWithTag("Player");
player = playerGO.transform;
if (CameraFollow.CF == null)
CameraFollow.CF = this;
}
void FixedUpdate()
{
//Error Prevention
if (player == null)
return;
//Target position
Vector3 playerPos = player.position;

~IF AND ELSE IF~

//Vertical Clamping
if (YMinEnabled && YMaxEnabled)
{
playerPos.y = Mathf.Clamp(player.position.y, YMinValue, YMaxValue);
}
else if (YMinEnabled)
{
playerPos.y = Mathf.Clamp(player.position.y, YMinValue, player.position.y);
}
else if (YMaxEnabled)
{
playerPos.y = Mathf.Clamp(player.position.y, player.position.y, YMaxValue);
}
//Horizontal Clamping
if (XMinEnabled && XMaxEnabled)
{
playerPos.x = Mathf.Clamp(player.position.x, XMinValue, XMaxValue);
}
else if (XMinEnabled)
{
playerPos.x = Mathf.Clamp(player.position.x, XMinValue, player.position.x);
}
else if (XMaxEnabled)
{
playerPos.x = Mathf.Clamp(player.position.x, player.position.x, XMaxValue);
}
//Align camera and the player's z position
playerPos.z = transform.position.z;
transform.position = Vector3.SmoothDamp(transform.position, playerPos, ref velocity,
smoothTime);
}
//===============PROCEDURE===============//
public IEnumerator Shake(float duration, float magnitude)
//Purpose:
To shake the camera in a random way
//float duration: Controls how long the shake occurs
//float magnitude: Controls how powerful the shake is
{
Vector3 originalPos = transform.localPosition;
float elapsed = 0f;

~WHILE LOOP~
while(elapsed<duration)
{
float x = Random.Range(-1f, 1f) * magnitude;
float y = Random.Range(-1f, 1f) * magnitude;
transform.localPosition = new Vector3(originalPos.x + x, originalPos.y+y,
originalPos.z);
elapsed += Time.deltaTime;
yield return null;
}
transform.localPosition = originalPos;
}
}

Crosshair.cs
/*
* Author: Alex Kam
* Date: 2-8-19
* Licence: Unity Personal Editor Licence
*/
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
public class Crosshair : MonoBehaviour
{
void Start()
{
Cursor.visible = false;
}
// Update is called once per frame
void Update()
{
Vector2 crosshairPos = Camera.main.ScreenToWorldPoint(Input.mousePosition);
transform.position = crosshairPos;
}
}

CustomisationOptions.cs
/*
* Author: Alex Kam
* Date: 2-8-19
* Licence: Unity Personal Editor Licence
*/
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;
using TMPro;
public class CustomisationOptions : MonoBehaviour
{
//Create a singleton/record of the game object
public static CustomisationOptions CO;
//Name Variables
public Text nameText;
public string playerName;

~USE OF ARRAYS~
//Colour Variables
public GameObject border;
public Transform[] buttons = new Transform[4];
public Image player;
public Color[] playerColour = new Color[4];
public int colourChoice;
//Slider Variables

public Slider[] sliders = new Slider[3];
public GameObject[] addButtons = new GameObject[3];
public float maxPoints = 10f;
public float fireRate = 0f;
public float bulletSpeed = 0f;
public float damage = 0f;
public float sumOfPoints;
public TextMeshProUGUI[] pointsText = new TextMeshProUGUI[3];
public TextMeshProUGUI maxPointsText;
private void Awake()
{
//Creates a singleton
if (CustomisationOptions.CO == null)
CustomisationOptions.CO = this;
}
void Update()
{
player.color = playerColour[colourChoice];
//Changes name of the player according to the input field
playerName = nameText.text;

~NESTED IF ELSE~
if (sliders[0] != null)
{
sumOfPoints = SumOfSliders(sliders);
if (sumOfPoints >= maxPoints)
{
foreach (GameObject item in addButtons)
item.SetActive(false);
}
else
{
foreach (GameObject item in addButtons)
item.SetActive(true);
}
}
maxPointsText.text = "Max Points: " + (maxPoints - sliders[0].value - sliders[1].value sliders[2].value).ToString();
pointsText[0].text = sliders[0].value.ToString();
pointsText[1].text = sliders[1].value.ToString();
pointsText[2].text = sliders[2].value.ToString();
}
//===============PROCEDURE===============//
public void White()
//Purpose:
Selects white when button is chosen
{
Debug.Log("White was chosen");
border.SetActive(true);
border.transform.position = buttons[0].position;
colourChoice = 0;
FindObjectOfType<AudioManager>().Play("Button");
}
//===============PROCEDURE===============//
public void Blue()
//Purpose:
Selects blue when button is chosen
{
Debug.Log("Blue was chosen");
border.SetActive(true);

border.transform.position = buttons[1].position;
colourChoice = 1;
FindObjectOfType<AudioManager>().Play("Button");
}
//===============PROCEDURE===============//
public void Red()
//Purpose:
Selects red when button is chosen
{
Debug.Log("Red was chosen");
border.SetActive(true);
border.transform.position = buttons[2].position;
colourChoice = 2;
FindObjectOfType<AudioManager>().Play("Button");
}
//===============PROCEDURE===============//
public void Purple()
//Purpose:
Selects purple when button is chosen
{
Debug.Log("Purple was chosen");
border.SetActive(true);
border.transform.position = buttons[3].position;
colourChoice = 3;
FindObjectOfType<AudioManager>().Play("Button");
}
//===============PROCEDURE===============//
public void IncreaseFireRate()
//Purpose:
Increases fire rate when button is chosen
{
sliders[0].value += 1;
fireRate = sliders[0].value * 2;
Debug.Log("Fire Rate is: " + fireRate);
FindObjectOfType<AudioManager>().Play("Add");
}
//===============PROCEDURE===============//
public void DecreaseFireRate()
//Purpose:
Decreases fire rate when button is chosen
{
sliders[0].value -= 1;
fireRate = sliders[0].value * 2;
Debug.Log("Fire Rate is: " + fireRate);
FindObjectOfType<AudioManager>().Play("Delete");
}
//===============PROCEDURE===============//
public void IncreaseBulletSpeed()
//Purpose:
Increases bullet speed when button is chosen
{
sliders[1].value += 1;
bulletSpeed = sliders[1].value * 3;
Debug.Log("Bullet Speed is: " + bulletSpeed);
FindObjectOfType<AudioManager>().Play("Add");
}
//===============PROCEDURE===============//
public void DecreaseBulletSpeed()
//Purpose:
Decreases bullet speed when button is chosen
{
sliders[1].value -= 1;

bulletSpeed = sliders[1].value * 3;
Debug.Log("Bullet Speed is: " + bulletSpeed);
FindObjectOfType<AudioManager>().Play("Delete");
}
//===============PROCEDURE===============//
public void IncreaseDamage()
//Purpose:
Increases damage when button is chosen
{
sliders[2].value += 1;
damage = sliders[2].value * 10;
Debug.Log("Damage is: " + damage);
FindObjectOfType<AudioManager>().Play("Add");
}
//===============PROCEDURE===============//
public void DecreaseDamage()
//Purpose:
Decreases damage when button is chosen
{
sliders[2].value -= 1;
damage = sliders[2].value * 10;
Debug.Log("Damage is: " + damage);
FindObjectOfType<AudioManager>().Play("Delete");
}
//===============FUNCTION===============//
public float SumOfSliders(Slider[] sliders)
//Purpose:
Finds the sum of the value of the sliders
//Slider[] sliders: Calls all available sliders in the array
{
float sum = 0f;
foreach (Slider item in sliders)
sum += item.value;
return sum;
}
}

GameController.cs
/*
* Author: Alex Kam
* Date: 2-8-19
* Licence: Unity Personal Editor Licence
*/
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;
public class GameController : MonoBehaviour
{
public static GameController GC;
//Player Variables
public int colourChoice;
public string playerName;
public float fireRate;
public float bulletSpeed;
public float damage;

public int wavesCompleted;
public bool addEntry = false;
private void Awake()
{
if (GameController.GC == null)
GameController.GC = this;
DontDestroyOnLoad(gameObject);
}
public void Update()
{

~USE OF FLAGS~
if(addEntry)
{
Debug.Log(PlayerController.PC.wavesCompleted + PlayerController.PC.myName);
Highscores.AddHighscoreEntry(PlayerController.PC.wavesCompleted,
PlayerController.PC.myName);
Debug.Log("Added Entry");
addEntry = false;
}
if(SceneManager.GetActiveScene().buildIndex == 0)
{
Cursor.visible = true;
GameObject customisation = GameObject.Find("CustomiseMenu");
if(customisation!=null)
{
SetPlayerChoices();
}
}
}
//===============PROCEDURE===============//
void SetPlayerChoices()
//Purpose:
Sets the player's choices to the ones that were chosen previously
{
colourChoice = CustomisationOptions.CO.colourChoice;
playerName = CustomisationOptions.CO.playerName;
fireRate = CustomisationOptions.CO.fireRate;
bulletSpeed = CustomisationOptions.CO.bulletSpeed;
damage = CustomisationOptions.CO.damage;
}
//===============PROCEDURE===============//
public void PlayGame()
//Purpose:
Starts the main game if the button is chosen
{
Debug.Log("Start button was pressed");
SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex + 1);
}
//===============PROCEDURE===============//
public void QuitGame()
//Purpose:
Quits the application if the button is chosen
{
Debug.Log("Quit button was pressed");
Application.Quit();
}
}

GameOver.cs
/*
* Author: Alex Kam
* Date: 2-8-19
* Licence: Unity Personal Editor Licence
*/
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.SceneManagement;
public class GameOver : MonoBehaviour
{
//Game Over Variables
public static GameOver GO;
public bool gameOver = false;
public GameObject gameOverCanvas;
//Text Variables
public TextMeshProUGUI name;
public TextMeshProUGUI waves;
private void Awake()
{
if (GameOver.GO == null)
GameOver.GO = this;
}
//===============PROCEDURE===============//
public void EndGame()
//Purpose:
Ends the game and puts up the game over window
{
gameOver = true;
if (gameOver)
{
Debug.Log("Game Over");
AudioManager.AM.Play("GameOver");
name.text = PlayerController.PC.myName;
waves.text = PlayerController.PC.wavesCompleted.ToString() ;
gameOverCanvas.SetActive(true);
gameOver = false;
GameController.GC.addEntry = true;
}
}
//===============PROCEDURE===============//
public void Quit()
//Purpose:
Quits the application if the button is chosen
{
Debug.Log("Go back to menu");
SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex - 1);
}
public void Retry()
//Purpose:
Restarts the game scene if the button is chosen
{
SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
}
}

<

HealthBar.cs
/*
* Author: Alex Kam
* Date: 2-8-19
* Licence: Unity Personal Editor Licence
*/
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
public class HealthBar: MonoBehaviour
{
//Declare Vector3 to be healthbar's position
Vector3 localScale;
//Declare Color fields
[SerializeField] public Color fullColour;
[SerializeField] public Color lowColour;
[SerializeField] public Image bar;
void Start()
{
localScale = transform.localScale;
}
void Update()
{
HealthController();
}
//===============PROCEDURE===============//
void HealthController()
//Purpose:
Adjusts the colour and size of the HP bar according to its value
{
localScale.x = 3 * PlayerController.healthAmount / 100;
transform.localScale = localScale;
//Change colour from Green to Red according to health amount
bar.color = Color.Lerp(lowColour, fullColour, PlayerController.healthAmount/100);
}
}

Highscores.cs (JOINT CONTRIBUTION)
/*
* Author: Alex Kam and Yuta Kataoka
* Date: 2-8-19
* Licence: Unity Personal Editor Licence
*/
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using TMPro;
public class Highscores : MonoBehaviour
{
private Transform entryContainer;

private Transform entryTemplate;
private List<HighscoreEntry> highscoreEntryList;
private List<Transform> highscoreEntryTransformList;
HighscoresJSON highscores;
private void Awake()
{
entryContainer = transform.Find("HighscoreContainer");
entryTemplate = entryContainer.Find("template");
entryTemplate.gameObject.SetActive(false);
//Quick Create Highscores or Refresh
//CreateNewHighscores();
//Load The Table
LoadTable();
//Sort the Table
SortTable();
//Create the Table
CreateTable();
Debug.Log(PlayerPrefs.GetString("highscoreTable"));
}
//===============PROCEDURE===============//
private void CreateNewHighscores()
//Purpose:
Creates a new HighscoresJSON file and some placeholder highscores
//Author: ALEX KAM
{
highscoreEntryList = new List<HighscoreEntry>()
{
new HighscoreEntry{ name = "Aaron", waves = 5 },
new HighscoreEntry{ name = "Phillip", waves = 10},
new HighscoreEntry{ name = "Molly", waves = 4 },
new HighscoreEntry{ name = "Ben", waves = 6 },
new HighscoreEntry{ name = "Kenny", waves = 2 },
};

~USE OF JSON FILES~
HighscoresJSON highscores = new HighscoresJSON { highscoreEntryList = highscoreEntryList
};
string json = JsonUtility.ToJson(highscores);
PlayerPrefs.SetString("highscoreTable", json);
PlayerPrefs.Save();
Debug.Log(PlayerPrefs.GetString("highscoreTable"));
}
//===============PROCEDURE===============//
public static void AddHighscoreEntry(int waves, string name)
//Purpose:
Adds a new highscore entry to the JSON file
//int waves:
Stores the number of waves that were completed
//string name:
Stores the name of the last player
//Author: ALEX KAM
{
//Create a Highscore Entry
HighscoreEntry highscoreEntry = new HighscoreEntry { waves = waves, name = name };
//Load saved Highscores
string jsonString = PlayerPrefs.GetString("highscoreTable");
HighscoresJSON highscores = JsonUtility.FromJson<HighscoresJSON>(jsonString);
//Add new entry to Highscores

highscores.highscoreEntryList.Add(highscoreEntry);
//Save the updated highscores
string json = JsonUtility.ToJson(highscores);
PlayerPrefs.SetString("highscoreTable", json);
PlayerPrefs.Save();
}
//===============PROCEDURE===============//
private void LoadTable()
//Purpose:
Loads the highscore JSON file
//Author: YUTA KATAOKA
{
//Loads table from PlayerPrefs
string jsonString = PlayerPrefs.GetString("highscoreTable");
highscores = JsonUtility.FromJson<HighscoresJSON>(jsonString);
}

~USE OF BUBBLE SORT~
//===============PROCEDURE===============//
private void SortTable()
//Purpose:
Sorts the highscores according to waves completed
//Author: YUTA KATAOKA
{
HighscoreEntry temp;
bool swaps = true;

~USE OF DO LOOP~
do
{
swaps = false;
for (int i = 0; i < highscores.highscoreEntryList.Count - 1; i++)
{
if (highscores.highscoreEntryList[i].waves < highscores.highscoreEntryList[i +
1].waves)
{
temp = highscores.highscoreEntryList[i];
highscores.highscoreEntryList[i] = highscores.highscoreEntryList[i + 1];
highscores.highscoreEntryList[i + 1] = temp;
swaps = true;
}
}
}
while (swaps);
}
//===============PROCEDURE===============//
private void CreateTable()
//Purpose:
Creates a table comprised of game objects on screen
//Author: ALEX KAM
{
int i = 0;
highscoreEntryTransformList = new List<Transform>();
foreach (HighscoreEntry highscoreEntry in highscores.highscoreEntryList)
{
i++;
if (i<=10)
CreateHighscoreEntryTransform(highscoreEntry, entryContainer,
highscoreEntryTransformList,0);
}
}

~USE OF LINEAR SEARCH~
//===============PROCEDURE===============//

public void Search()
//Purpose:Deletes previous game objects, searches for player name, and creates list findings
//Author: ALEX KAM
{
//Reset the Container and Template
entryContainer = transform.Find("SearchCanvas").Find("SearchContainer");
entryTemplate = entryContainer.Find("template");
entryTemplate.gameObject.SetActive(false);
//Delete all existing search containers
GameObject[] existingSearch = GameObject.FindGameObjectsWithTag("search");
//If array is not empty, then destroy all game objects
if (existingSearch.Length>0)
{
int i = 0;
while (i < existingSearch.Length)
{
Destroy(existingSearch[i].gameObject);
i++;
}
}
//Find the Text
string inputText =
transform.Find("SearchCanvas").Find("SearchInput").Find("TextArea").Find("Text")
.GetComponent<TextMeshProUGUI>().text;
//Trim off the space at the end
string search = "";
for(int i=0; i<inputText.Length-1; i++)
{
search += inputText[i];
//Debug.Log(search);
}
//Redeclare some variables for searching
int rank = 1;
highscoreEntryTransformList = new List<Transform>();
//Find and create all instances
foreach (HighscoreEntry highscoreEntry in highscores.highscoreEntryList)
{
//If found then create using rank
if (highscoreEntry.name.Equals(search))
{
CreateHighscoreEntryTransform(highscoreEntry, entryContainer,
highscoreEntryTransformList,rank);
Debug.Log("Found!");
}
rank++;
}

/* Whitebox Testing
for (int i=0; i<inputText.Length-1; i++)
{
Debug.Log(inputText[i]);
}
Debug.Log(inputText + inputText.Length);
Debug.Log(highscores.highscoreEntryList[0].name+
highscores.highscoreEntryList[0].name.Length);
Debug.Log(inputText.Equals(highscores.highscoreEntryList[0].name));
*/

}
//===============PROCEDURE===============//
private void CreateHighscoreEntryTransform(HighscoreEntry entry, Transform container,
List<Transform> transformList, int overrideRank)
//Purpose:
Creates a game object according to coordinates, and transform
//HighscoreEntry entry: Holds the values of waves completed and player name
//List<Transform> transformList: Determines where and what game objects are created
//int overrideRank: Only to be used when searching as it shows true rank
//Author: ALEX KAM
{
float templateHeight = 40;
Transform entryTransform = Instantiate(entryTemplate, container);
RectTransform entryRectTransform = entryTransform.GetComponent<RectTransform>();
entryRectTransform.anchoredPosition = new Vector2(0, -templateHeight *
transformList.Count);
entryTransform.gameObject.SetActive(true);

~USE OF SWITCH~
int rank = transformList.Count + 1;
string rankString;
switch (rank)
{
case 1: rankString = "1ST"; break;
case 2: rankString = "2ND"; break;
case 3: rankString = "3RD"; break;
default: rankString = rank + "TH"; break;
}
int waves = entry.waves;
string name = entry.name;
if(overrideRank==0)
entryTransform.Find("posText").GetComponent<TextMeshProUGUI>().text = rankString;
else
entryTransform.Find("posText").GetComponent<TextMeshProUGUI>().text =
overrideRank.ToString();
entryTransform.Find("nameText").GetComponent<TextMeshProUGUI>().text = name;
entryTransform.Find("wavesText").GetComponent<TextMeshProUGUI>().text = waves.ToString();
transformList.Add(entryTransform);
}
private class HighscoresJSON
{
public List<HighscoreEntry> highscoreEntryList;
}
[System.Serializable]
public class HighscoreEntry
{
public int waves;
public string name;
}
}

PlayerController.cs
/*
* Author: Alex Kam
* Date: 2-8-19
* Licence: Unity Personal Editor Licence

*/
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
public class PlayerController : MonoBehaviour
{
//Singleton
public static PlayerController PC;
//Speed Variables
public float speed;
private Rigidbody2D rb;
//Health Variables
public static float healthAmount;
public static float maxHealth;
//Customisation Variables
public SpriteRenderer player;
public string myName;
public Color[] playerColour = new Color[4];
//Wave Variables
public int wavesCompleted = 0;
private void Awake()
{
if (PlayerController.PC == null)
PlayerController.PC = this;
}
void Start()
{
UsePlayerChoices(GameController.GC.colourChoice, GameController.GC.playerName);
}
void Update()
{
FaceMouse(Input.mousePosition);
if(healthAmount<=0)
{
Destroy(gameObject);
GameOver.GO.EndGame();
}
//rb.MovePosition(rb.position + moveVelocity * Time.fixedDeltaTime);
wavesCompleted = SpawnController.SC.wavesCompleted;
}
void FixedUpdate()
{
Vector2 moveInput = new Vector2(Input.GetAxis("Horizontal"), Input.GetAxis("Vertical"));
Move(moveInput);
}
//===============PROCEDURE===============//
void UsePlayerChoices(int colourChoice, string playerName)
//Purpose:
Sets the player settings to what was chosen
//int colourChoice: Determines what colour the player is
//string playerName: Determines what name the player has
{

//Declare health and max health
healthAmount = 100f;
maxHealth = 100f;
rb = GetComponent<Rigidbody2D>();
//Change colour according to what was chosen
player.color = playerColour[colourChoice];
//Change name according to what was typed
if (string.IsNullOrEmpty(playerName))
myName = "Player";
myName = playerName;
}
//===============PROCEDURE===============//
void Move(Vector2 dir)
//Purpose:
Moves the player in the direction that was inputted
//Vector2 dir:
Determines the x and y direction of the player
{
rb.MovePosition(rb.position + dir * speed * Time.fixedDeltaTime);
}
//===============PROCEDURE===============//
void FaceMouse(Vector3 input)
//Purpose:
Rotates the player towards the position of the mouse
//Vector3 input:
Stores the x,y,z location of the mouse
{
Vector3 mousePosition = input;
mousePosition = Camera.main.ScreenToWorldPoint(mousePosition);
Vector2 direction = new Vector2(
mousePosition.x - transform.position.x,
mousePosition.y - transform.position.y);
transform.up = direction ;
}
void OnTriggerEnter2D(Collider2D col)
{
if(col.gameObject.tag.Equals("spike"))
{
healthAmount -= 1f;
}
if (healthAmount <= maxHealth)
{
if (col.gameObject.tag.Equals("healthPack"))
{
healthAmount += 10f;
if(healthAmount>maxHealth)
{
healthAmount = maxHealth;
}
}
}
}
}

PlayerController.cs
/*

* Author: Alex Kam
* Date: 2-8-19
* Licence: Unity Personal Editor Licence
*/
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
public class SpawnController : MonoBehaviour
{
public static SpawnController SC;
public GameObject playerPrefab;
public Transform playerSpawn;
public Transform[] enemySpawn;
public enum SpawnState { SPAWNING, WAITING, COUNTING };

~MORE RECORDS~
[System.Serializable]
public class Wave
{
public string name;
public int enemyNum;
public Transform enemy;
public int bossNum;
public Transform boss;
public float rate;
}
public Wave[] waves;
public int nextWave = 0;
int spawnPicker;
public float timeBetweenWaves = 5f;
public float waveCountdown = 0f;
public int wavesCompleted = 0;
private float searchCountdown = 1f;
public float multiplier = 1;
private SpawnState state = SpawnState.COUNTING;
private void Awake()
{
if (SpawnController.SC == null)
SpawnController.SC = this;
}
void Start()
{
if(enemySpawn.Length ==0)
Debug.LogError("No spawn points are referenced");
CreatePlayer(playerPrefab);
waveCountdown = timeBetweenWaves;
}
//===============PROCEDURE===============//
void CreatePlayer(GameObject player)
//Purpose:
Instantiates a player game object into the arena
//GameObject player: Stores the player prefab
{
Instantiate(player, new Vector3(0, 0, 0), Quaternion.identity);
}

void Update()
{
if(state == SpawnState.WAITING)
{

~USE OF SENTINEL~
if(!EnemyIsAlive())
{
//Begin a new Wave
WaveCompleted();
if (wavesCompleted % 3 == 0)
{
RegenHP();
}
return;
}
else
{
return;
}
}
if (waveCountdown <= 0)
{
if(state != SpawnState.SPAWNING)
{
StartCoroutine(SpawnWave(waves[nextWave],multiplier));
}
}
else
{
CountDown();
}
}
//===============PROCEDURE===============//
void CountDown()
//Purpose:
Deducts waveCountdown by the time
{
waveCountdown -= Time.deltaTime;
}
//===============PROCEDURE===============//
void RegenHP()
//Purpose:
Regens the player's health to 100%
{
PlayerController.healthAmount = PlayerController.maxHealth;
AudioManager.AM.Play("HP");
}
//===============PROCEDURE===============//
void WaveCompleted()
//Purpose:
Sets the state to COUNTING and increments the wave and sometimes multiplier
{
Debug.Log("Wave Completed");
state = SpawnState.COUNTING;
waveCountdown = timeBetweenWaves;
if(nextWave+1 > waves.Length-1)
{
nextWave = -1;
multiplier++;
Debug.Log("All Waves Completed! Looping...");

}
wavesCompleted++;
nextWave++;
}
//===============FUNCTION===============//
bool EnemyIsAlive()
//Purpose:
Checks whether any enemies are alive every so often
{
searchCountdown -= Time.deltaTime;
if (searchCountdown <= 0f)
{
if (GameObject.FindGameObjectWithTag("Enemy") == null &&
GameObject.FindGameObjectWithTag("Boss") == null)
return false;
}
return true;
}

~USE OF FOR LOOPS~
//===============PROCEDURE===============//
IEnumerator SpawnWave(Wave _wave, float difficulty)
//Purpose:
Spawns a wave of enemies and bosses through instantiation
//Wave _wave:
Stores the number of enemies and bosses to be spawned
//int difficulty:
Determines the multiplier of enemies to be spawned
{
Debug.Log("Spawning Wave: " + _wave.name);
state = SpawnState.SPAWNING;
for(int i =0; i<_wave.enemyNum*difficulty; i++)
{
SpawnEnemy(_wave.enemy);
yield return new WaitForSeconds(1f / _wave.rate);
}
if (waves[nextWave].boss != null)
{
for (int i = 0; i < _wave.bossNum*difficulty; i++)
{
SpawnBoss(_wave.boss);
yield return new WaitForSeconds(1f / _wave.rate);
}
}
state = SpawnState.WAITING;
yield break;
}
//===============PROCEDURE===============//
void SpawnEnemy(Transform _enemy)
//Purpose:
Spawns an enemy
//Transform _enemy: Stores the enemy prefab
{
Debug.Log("Spawning Enemy: " + _enemy.name);
spawnPicker = Random.Range(0, enemySpawn.Length);
Instantiate(_enemy, enemySpawn[spawnPicker].position, enemySpawn[spawnPicker].rotation);
}
//===============PROCEDURE===============//
void SpawnBoss(Transform _boss)
//Purpose:
Spawns a boss
//Transform _boss: Stores the boss prefab
{
Debug.Log("Spawning Boss: " + _boss.name);
spawnPicker = Random.Range(0, enemySpawn.Length);

Instantiate(_boss, enemySpawn[spawnPicker].position, enemySpawn[spawnPicker].rotation);
}
}

Taking a Closer Look at the Linear Search and HighscoresJSON File
The highscores are sorted and saved by the Highscores.cs script. It uses a bubble sort and a linear
search to sort the data meaningfully. The data is stored in a JSON file by a Unity function called
PlayerPrefs which is transferred to string and used by the program.

Figure 4.1.2: Linear search in action

Figure 4.1.3: Console log of Json file to string
On a Windows machine, the PlayerPrefs are stored in:
Computer/HKEY_CURRENT_USER/Software/CompanyName/ProjectName
Below is the file location in JSON format that is accessed by the program. The location of the file will
change depending on the computer’s operating system.

Figure 4.1.4: JSON file location for PlayerPrefs

Mastery of Bubble Sort
As Yuta was the one who created the script for sorting the Highscore file, I still need to show mastery
of a bubble sort. Below is a BlueJ program written in Java that replicates the process of sorting the
highscore table using preset highscores.

Figure 4.1.4: Bubble sort in action
HighscoresBubbleSort.java
/*
* Alexander Kam
* V.1
* Last Modified: 13-5-19
* Bubble Sort Algorithm
*/
import java.lang.Math;
import static java.lang.System.out;
import java.util.Random;
import java.util.Scanner;
class Highscores
{
String name;
int wavesCompleted;
}
public class HighscoreBubbleSort
{
public static void main(String[] args)
{
out.println("====================================");
out.println("
Prototype of Bubble Sort
");
out.println("====================================");

Highscores[] highscores = new Highscores[5];
QuickCreate(highscores);
out.println("\nBefore Sort");
print(highscores);
out.println("\n\nAfter Sort");
BubbleSort(highscores);
print(highscores);
out.println("\nProgram has finished");
}
public static void QuickCreate(Highscores[] highscores)
{
for(int i=0; i<highscores.length; i++)
{
highscores[i] = new Highscores();
highscores[i].name = "Player "+i;
highscores[i].wavesCompleted = (int)(Math.random()*((6-1)+1)+1);
}
}
public static void BubbleSort(Highscores[] highscores)
{
int tempWaves;
String tempName;
boolean swaps = true;
do
{
swaps = false;
for(int i=0; i<highscores.length-1; i++)
{
if(highscores[i].wavesCompleted<highscores[i+1].wavesCompleted)
{
tempWaves = highscores[i].wavesCompleted;
tempName = highscores[i].name;
highscores[i].wavesCompleted = highscores[i+1].wavesCompleted;
highscores[i].name = highscores[i+1].name;
highscores[i+1].wavesCompleted = tempWaves;
highscores[i+1].name = tempName;
swaps = true;
}
}
}
while(swaps);
}
public static void print (Highscores[] highscores)
{
out.println("==============HIGHSCORES==============");
out.println("Rank\tName\t\tWaves Completed");
for(int i=0; i<highscores.length; i++)
{
out.print("\n"+(i+1)+"\t");
out.print(highscores[i].name +"\t");
out.print(highscores[i].wavesCompleted);
}
}
}

4.2. Evaluation
Using the Agile Approach
The Agile Approach to software development worked very well when developing the game. Since it
was a dynamic approach, we were able to make several changes to the game whilst maintaining a
tight schedule. This can be seen when the original project proposal was to be a ‘multiplayer game’.
However, after research and testing during the first week, this quickly changed to a ‘singleplayer
game’. If it weren’t for the agile approach, making the change would have been difficult as changes to
the schedule would have to be made.
The true effectiveness of the agile approach can be evaluated in the release of each iteration after
each sprint. These iterations built upon the last, adding new functionality and improving any mistakes.
The ability to test each iteration propelled game development immensely.
The agile approach was only limiting in its scope to delve into deeper and more complex problems.
Since each iteration was planned to bring new functions, it was difficult to focus on one function and
improve upon it heavily. As such, each function (e.g. player movement and projectile customisation)
was implemented without much change or complexity. Thus, the game feels fairly simplistic in its use.

The Final User Interface
In Section 1.4, one of the goals of the task was to develop an effective user interface. Some features
of the UI that were done well were:
UI Aspect

Example

The consistent placement of buttons
On the right, it can be seen that the main menu
and the pause menu share similar button
placements. The start/resume have similar
functions and are therefore placed at the top.
The quit button functions similarly in both
menus and are placed at the bottom.
Figure 4.2.1: Buttons for main and pause menus

Appropriate use of colour and graphics
Careful planning was taken in order to ensure
that the use of colour was not misused. In the
arena, the colour of the enemies and bosses, as
well as their projectiles, are easily identifiable.
The player sticks out considerably due to the
bright colour choices. These colours ensure that
the UI is somewhat aesthetically pleasing.
Figure 4.2.2: Colour and graphics in the arena

However, the UI was far from perfect. For instance, the crosshair was occasionally overlapped by the
walls of the game, making it difficult to see where the player was aiming. This can be seen in Figure
4.2.2. Additionally, it is difficult to see where the player is facing. Without an indication on the player’s
avatar on where it is facing, the player can often be confused and be forced to readjust his/her view.

Results of Testing
The wide range of methods of testing was very useful to the overall development of the game.
Whitebox and Blackbox testing were heavily used throughout each sprint iteration. They allowed for
deeper analysis of the code and the game, with testing occurring on the major features introduced in
each iteration. Sprint 1 was tested on player movement and camera control, Sprint 2 was tested on the
menu UI and projectile customisation, Sprint 3 was tested on the wave system, and Sprint 4 was
tested on the pause menu and particle systems. These took two differing perspectives on the
operations of the game:
➔ The impact of the code on the user interface
➔ The impact of the code on the operation of the program
Each result allowed us to analyse what was working and what factors needed improvement, allowing
each iteration to be far better than the last.
The desk checks took a more focused approach to testing the boundaries of particular scripts. These
were the CustomisationOptions script and the SpawnController script. These two relied heavily on the
state of flags and enumerators to keep track of what was happening. The results of the desk checks
confirmed that the scripts were very dependent on player interaction and could be vulnerable to bugs
if handled incorrectly. Thus, the desk checks were able to improve the scripts further to avoid them.

Overall Success of Solution
Overall, the solution effectively solved its problem whilst adding additional features that improved
gameplay. The successful implementation of the highscore table and the working wave system were
the main highlights of the game, as they allowed the player to keep track of his/her progress and
compare it against the efforts of others. Although it was only a singleplayer game, it performed very
well and would be entertaining for several people.
The solution only lacked in its creative aspect. Certain features such as sound effects, music, and
graphics were either omitted or sourced online. While the sound effects were royalty free, they were
not fully suited to the theme and could be better if made originally. The lack of music and simplistic
graphics and particles made the game seem fairly boring in the visual aspect.
In future software solutions, more attention could be placed on further developing the creative
aspects of the game, by employing specialists such as artists and musicians. In addition to the agile
approach, the prototyping approach could be used to create prototypes of each iteration in order to
send them for testing by users. As our solution was only tested by us, it lacked the multifaceted
response that testing normally receives. As such, prototypes could collect valuable user feedback to
make more founded improvements to the game.

