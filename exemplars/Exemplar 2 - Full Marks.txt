Contents

2

Defining the problem

4

Identification of the problem

4

Communication to establish requirements

5

Idea generation

6

Investigate alternative approaches to a solution

6

Requirements

7

Develop project plan

7

Understanding user requirements

8

Design specifications: data types selected

8

Design specifications: appropriate data structures

8

Representation of the system using a storyboard

9

Representation of the system using an IPO Chart

9

Representation of the system with context and DFD diagrams

10

Representation of the system with an initial structure chart

11

Limited prototype development

12

Consideration of all applicable social and ethical issues

13

Planning and design

14

Annotated interface design

14

Selection of software environment

14

Identification of appropriate hardware

15

Initial data dictionary

15

Definition of required validation processes

16

Definition of files

17

Record layout and creation

17

Algorithm design: structure charts

19

Algorithm design: pseudocode for main modules

19

Test plan

25

Enabling and incorporating feedback from users at regular intervals

27

Use of CASE Tools

27
2

Implementation

28

Tools and modules used

28

Final data dictionary

29

Solution testing and improvements

31

Test plan

31

System and user documentation

35

Evidence of regular communication with stakeholders

35

Evidence of online help

36

Evaluation/Maintenance

37

Testing of user requirements

37

Feedback

37

Evaluation of social and ethical considerations

38

Appendix

40

Project logbook

40

Surveys/Interviews

44

Full code listing

44

Record of communication

45

Backup Procedures

46

References and resources used

46

3

Defining the problem

Identification of the problem (Problem statement) – I am a very keen golfer and I try to play
whenever I can. However, when watching professionals play on YouTube etc; I came to the quick
conclusion that they use a large arsenal of technological equipment on top of their pricey golf clubs
in order to assist them in knowing what clubs to hit depending on how far they are from the green.
The main apparatus that most serious golfers own are called range finders. These have become a
necessity as of recent in the amateur to professional golf scene. Some range finders can go for
upwards of $800 as seen in figure 1, and as a full-time student, I certainly didn’t have the money for
this. Therefore, when I was notified about this project I figured it would give me the perfect chance
to create a free and user-friendly golf tracker that could account for current wind speeds and your
GPS location on a specific golf course that you choose. Furthermore, I often find myself debating on
what club I should hit depending on where I am on the course. My software should eliminate this
issue as the user will be recommended a club by my software’s algorithm depending on the distance,
windspeed and the personalised distances they will enter into the software prior to using it.

Figure 1 – Range finder price

4

Communication to establish requirements (Interviews, observation and questionnaires)

From my participation in and observation golf over the past year, I noticed that there was no free
and reliable method to track distances whilst playing. This was reflected in golfers of all skill levels
including myself.

To see if this was a good idea to base my project on, I interviewed my friend, Ed Proctor, who
happens to be a professional golfer at 17 years old. Although he has all of the technological gear, he
stated that there was certainly a need for a free golf tracker software amongst the members at his
local golf club. When I told him how the tracker accounts for live wind speeds and applies it to the
algorithm he said “That’s awesome. I’ve never seen that in a golf tracker before. Sometimes there
are extreme winds on the course and you kind of just have to guess what direction to aim at”.
Furthermore, I asked my friends that I play golf with if they’d use the software, and the results were
very positive. I was able to conclude from my interviews that there was a certain hole in the market
for free golf trackers and my software should solve this issue if executed correctly.

Figure 2 – Ed Proctor at a tournament in Melbourne

5

Idea generation (Alternative solutions) –

A second way you could solve my problem would be to use a golf watch. These watches are
specifically manufactured to show you yardages on certain holes at any golf course. However, alike
the range finder, these golf watches are very expensive (generally in the price range of $500 - $900)
and also don’t offer very many features. As the pin of most golf courses is changed every day, the
watch doesn’t account for this meaning the user isn’t able to get exact distances. Furthermore, the
small form factor of the watch is hard to interact with and the small size of the watch face may pose
usability issues. Lastly, the watch only allows the user to see distances from the tee box to the green.
This means if the user is on the fairway, they would only be able to estimate the distance to the pin
themselves as the watch doesn’t have this functionality.

A third way to solve my problem would be to use golf tracker apps such as Hole19. This app is overall
functional, and I have used it myself in the past. It has a large range of golf courses worldwide that
the user can select and choose specific holes and unlike a golf watch, a user can see distances to the
green from anywhere on the hole, not just the tee box. However, the issue with this app and others
alike is that although it is originally free, a user needs to purchase a subscription fee after a certain
amount of uses. This fee is generally between $50 and $100 per year depending on the app you use.
Furthermore, these apps don’t account for live wind speeds like my software will.

Investigate alternative approaches to a software solution (feasibility study) –

A way to solve this issue without the use of software would be to manually measure the distance
between you and the green. All golf courses give the player the total distance of each hole, however
once you are on the fairway it is very difficult to get an accurate reading of the distance between you
and the green. This leads players such as me to roughly estimate distances which is generally
incorrect in many scenarios and results in ball going too short or too long. At some specific golf
courses there may be flags around trees to give the player a somewhat accurate reading of how far
they are from the green, however this isn’t a common occurrence (certainly not at the courses I
commonly play at).

Another way you could solve my problem without the use of software would be to use a range
finder as stated earlier. These range finders are largely accurate and account for the pins being
moved daily. However, the main issue with them is the price and the overall functionality. Not
everyone who plays golf is able to afford these range finders and that is why I decided to proceed
with my solution as it would free for the user whilst providing more functionality such as live wind
speeds so you know where to hit as well as a data base that saves the distances you are able to hit
with each club so the software can algorithmically suggest you a club to use based on how far you
are.

6

Requirements (Numbered list)

Must have: The program must run on all Windows and Mac machines at an appropriate resolution
such as 1920 x 1080 natively.
Must have: The program must be able to execute the algorithm successfully without any crashes.
Must have: The program must run on a computer with a minimum of 4GB of DDR3 RAM.
Must have: The program must run on a computer with a CPU with 2 or more cores and 2 or more
threads.
Must have: The program must give an accurate club recommendation and direction to aim based on
the inputs and live wind speed.
Must have: The program must have a local database where a user can make an account with an
encrypted password and enter their yardages on each club. The user will then be able to sign out
and log back in later and still have the yardages saved.
Must have: The user must be able to choose what hole they are on at a specific golf course and drag
and drop where they are at exactly (fairway, tee box, bunker etc) on a graphical representation of
the hole they are currently at.
Must have: The program must take live windspeeds from the area of the selected golf course
through an API and interpret them and feed them into an algorithm.
Could have: The software has multiple golf courses in its data base that the user can choose from
instead of just one.
Wish list: If the time allows for it I could add a GPS tracking function where the software knows
where the user is on the course so it autonomously tells them the distance between them and the
green without them having to drag and drop their location on the hole manually.

Develop project plan (Development approach used and Gantt chart)

I will be using the agile development method for this specific software project. My reasoning being
that I will need to create many mock prototypes of the interface as well as the algorithm I will create
to tell the user what club to use and what direction to hit it. This method is also very flexible and
considering I won’t be able to work on this project constantly – due to other commitments – I will
need a flexible schedule which is offered in an agile development approach. Gantt Chart Link
I plan to follow this Gantt chart to the best of my ability. However, my exams and this term are
scattered out throughout the back end of the term so I am unsure if I will be able to dedicate certain
weeks or days to project development. To work around this issue, I gave myself extra time in most of
the sections to account for my half yearly and task 3 exams
Logbook link

7

Understanding User Requirements
Design specifications: data types selected
Most of the data types I used were integers and strings as I was passing emails and passwords from
the users input to an external Json file that holds all of the user data. Furthermore, I was dealing
with users inputting distances which meant that I had to use integers for this process. These were in
meters and all whole numbers meaning the use of a float was unneeded. When users did input data
that went into the JSON file, I had to convert their input from an integer to a string in order to store
it externally. I had to reverse this and turn the string into an integer when I was pulling data from the
JSON file into my actual program.

Design specifications: appropriate data structures: I have used data structures such as
dictionaries in my program. When a user first creates an account and inputs a chosen email
and password, this input gets put into a dictionary first. Once it is in the dictionary it is then
appended to an external JSON file. When a user then goes to login to my program using the
details from the account they just created, the data in the JSON file will be read and placed
into a dictionary where an algorithm will check if their username and password matches
what is already in the database.

Data Structures Table:
Data Structure
Dictionary that temporarily holds the
user data such as their email,
password and golf distance input
data. The data in the dictionary is
then sorted into a external JSON file
for permanent residence.
The JSON file permanently holds all
the user data so when a user logs into
the software their credentials are
cross checked with the data in the
file. If there is a match of username
and password, the user is granted
entry into the program. If not, they
will have to make an account that will
then be appended to the JSON file.
An array that will hold the value of
each golf club and the distance that
the user has inputted for the specific
golf club. This will be stored as
temporary data and will be extracted
and passed through the algorithm.

Type
String and integer

Example Value
Abc123@Gmail.com
Password123#
124

The data is placed
into an array as A
unanimous string.

Username:
{“Username”: “Corey”,
“password”: “123”}

String

Clubs = [Driver: “231”, 4
Iron: “192” … ]

8

Representation of the system using diagrams (CASE tools):
Storyboard –

IPO chart –
Input:
Email and password on the
login menu

Process:
Firstly, the password with be
encrypted. The users input will
then be verified and matched
with the database. If the user
input doesn’t match what is on
the database a flag will be set
off.

User inputs an email and
password to create an account

The email will be added to the
database and the password
will be encrypted then added
to the database
The distances will be saved
onto that specific users data in
a JSON file.

When the user inputs their
distances for each club.

Wind speed input pulled from
a weather API key.

The data will extracted as a
raw string and then
deconstructed to pull just the
current live wind speeds from
the string. This will be placed

Output:
If there is a match between
the user input and what is
stored on the base base, the
user will be sent to the next
screen which is the main
menu. If not they will be
denied to the main menu have
will have to enter a different
email.
The user will be brought back
to the main login page where
they may use the account they
created to login
When the user starts a round
of golf on the software, the
distances will be used to
recommend a club for the
user.
This wind speed will be called
from the variable and placed in
the algorithm that determines
what direction the user should
hit depending on the speed
and positioning of the wind.
9

in a global variable as an
integer.

Context diagram–

10

Initial structure chart

11

Limited prototype development –

I created an initial prototype to observe the viability and reasonability of my solution. Furthermore,
this helped me to map out some of the challenges that I would face along my coding journey. For my
prototype to be a success and for it to give me accurate feedback and plans of action for the future
of my project it had to have:
x

x

x

x

Login System: The prototype must allow the user to login with an account that is stored on
the data base. If the user details aren’t already on the database, they will be denied the
progression to the next menu until they input a valid account.
Encrypted Password: For my user data to be kept safe on the external JSON file, I needed to
encrypt the user password so it cannot be leaked. I coded it so when a user enters a
password, it encrypts the password and then checks it with other encrypted passwords
already on the database. This ensures maximum user protection
Ability for the user to create an account: This was the hardest and most time consuming part
of the prototyping stage. I coded my prototype so when a user creates an account, their
email is sent to the external database and then their password entry is encrypted and then
placed on the external database. However, I needed a counter that would update every time
a new account was created so my program would know how many accounts to check for
validity when the user logged back in.
Enter club distances: I designed a menu that allowed the user to enter their club distances
before they tracked a round of golf on my program. This was a simple menu that saved the
entries to the users data in the database so they wouldn’t have to type in their distances
every-time they logged in and out.

12

Consider all Social and Ethical issues that apply –

Privacy:
The first social and ethical issue that could arise from my software is privacy issues concerning the
user. An example of this could include a data leak or breach. To prevent this from occurring, I will
not be storing any user data in the actual source code, but rather on an external JSON file.
Furthermore, I will be encrypting all the passwords that are entered into the database using SHA –
256. This complies with basic cybersecurity regulations. My program will also not ask for personal
information such as date of birth, address or credit card information. It will simply require the users
email and password input.

Inclusivity:
To increase my websites usability for visually impaired users, I have used a very basic and readable
colour scape for my interfaces. This is just a white background with black text. Black text on a white
background provides maximal value contrast and, therefore, optimal readability for body text. This
will ensure that users who are visually impaired, will be able to use my software in the exact same
way than if they weren’t visually impaired, with no extra hardships. Furthermore, my program will
be completely free to use meaning no economic issues should impact upon the inclusivity of the
software. There is also no specific language that could be perceived as offensive by users. To address
individuals with disabilities, they will be able to use shortcuts on their keyboard such as the ENTER
button, the arrow keys and the TAB button to operate functionally around the program.

Hardware Issues:
The software will be tested on school computers and laptops to ensure that everyone will be able to
run the software at the highest quality possible. It will run on most contemporary screen resolutions,
such as 1920x1080, and only requires a 2 Core CPU and 4GB of RAM to run. These basic
requirements are almost expected of a computer in this day in age.

Intellectual Property:
Because I am designing my program in a NSW approved school environment, my program is
owned by the Department of Education and Communities of NSW. Therefore, my program is
protected by copyright laws.

13

Planning and design
Interface design (Consistent, accessible, user-friendly design)
During my interface design process, I want to limit the number of pages that the user views to
maximise accessibility whilst making my program as user friendly and consistent as it could
possibility be. I believe I have achieved this with my current user interface prototype that I designed
using the CASE tool, Adobe Illustrator, as seen below:

Selection of software environment (OS and programming language)
I am choosing to write my program in Python 3.11 as I had previous experience in this language. I am
confident that I have the expertise to problem solve and troubleshoot issues that I will inevitably
come across in my programming journey. There are also countless resources and libraries online that
can aid me through this journey. More specifically, I had experimented with the Pygame Python
library in a previous project, however, found that this wasn’t appropriate for my predominantly
interface based project. Therefore, I concluded that I would need to use a different library, one that
was more interface design friendly. After doing some research I am deciding to use the PyQt5 library
as it allowed for easy and highly configurable interface designs.
I aim to code the main sections of this program on my Windows desktop as it is a lot faster than my
school laptop allowing me to complete the coding process of the project much more efficiently.
However, I will constantly make sure that the program will run on my Mac with no hardware issues
or limitations. By doing this I am able to assure that my program is able to run on any operating
system with almost any hardware.

14

Identification of appropriate hardware
I will test my program on two operating systems. Those being MacOS and Windows 10 and 11. After
running some tests on these systems using similar hardware intensive software’s, I established the
minimum hardware specifications being 8GB of DDR3 ram, a CPU with at least 4 cores and 4 threads
and any discrete graphics card. Any modern computer systems have far beyond these specifications,
so I concluded that my program would be able to run on most hardware systems that I had
encountered.

Data dictionary (Initial)
Below is the initial data dictionary for the main module of my program. This module handles both
the frontend and backend logic and algorithms.
Data ID
Email_number

Self.username_input

Self.password_input

Check_email

Hashed_password

Data

Course_selector

Self.*club
name*_input

Type
The amount of email address.
In the format of a string.
Imported as a text file.
The user inputted email
address. In the format of a
string. Exported to a JSON
file.
The user inputted password.
In the format of a string.
Exported to a JSON file after it
is encrypted.
Cycles through all email
addresses in the JSON file to
find a match. Uses a linear
searching algorithm.
This variable stores all hashed
or encrypted password after
it has been encrypted using
the hashlib.sha256 library.
Imports the user information
from the JSON file and
appends new email addresses
to the data base.
Holds the string of the course
that the user has selected to
play at. They choose this
through the software.
This variable stores the data
of each club distance that the
user has inputted within the
software. This is stored as an
integer

Format
Emailnumber = 5

{“username”:
coreyporter85@gmail.com}

{“password”: “asdjkgA@#fjhf”}

For i in range(email_number):

{"password": "506dba0dbc9f9654caf2d
272783262403943f1e38a98a9a6b998ba
39a3d00dca"}
Data = json.load(json_file)
Temp.append(data)

“Bondi Golf Course”

234 (meters)

15

Hole1

Holds the image of the
specific hole that the user
chooses to play at. The user
can then interact with the
image and drop a pin as to
the current location of their
ball

Check_password

This is stored as an array of
user data, email count and
the password that the user
has entered.

["userdata", number + 1, "password"]

I have declared email number as a string when it is originally appended and read from the text file.
This is because Pythons logic autonomously makes any data within a text file a string. However, I
didn’t want the email number to be this data type as I needed to increment it by 1 each time a new
user made an account. This meant I had to read the value or string from the text file and then
convert it to an integer, increment the integer in respect to the number of accounts and then lastly
append this new number to the text file as a string.

Definition of required validation processes
As my program is very user input orientated, I will ensure that my program has input validation
processes in action to minimise the program receiving an input that it can’t comprehend. This can be
seen in my program through:
1. The login and user creation account menu – I placed a minimum character floor on both text
fields for the email and password to ensure that the user would enter in a legitimate email
address. In a future model of this program, I would like to add a validation process that
doesn’t allow the user to make an account unless the email they use is active.
2. Distances input – When the user enters distances, there is a maximum character limit of 3.
The characters inputted can also only be integers as a string value will not be accepted. This
ensures that the program will be able to comprehend the users input every time.
3. Course selection – Instead of having the user type in what course they wanted to play at, I
added a drop-down selection box to my program. This limits the possible entries made by
the user and ensures that their selection is valid every time.
4. Functional validation – The functionality of my program is dependent on the user’s input. I
have placed measures to ensure that they can only input correct and valid inputs, however,
this cannot stop the user from entering information such as distances that are not correct to
them. Therefore, if a user wants to derive the greatest level of functionality from my
program, they must enter correct and valid information.
5. Security validation – I have tested the program for vulnerabilities to ensure that it is secure
against protentional threats. An example of this is that all passwords stored in the data base
are encrypted or hashed using a hashing library on Python. This means that even if a hacker
gains access to the data base, they will not be able to see user passwords. A second measure
of security that I have added is that when a user enters in a password to my software, it is
visually blurred out.

16

Definition of files
Below is a tabled list of all the major files in my project that I read, write, and append to and from:
File
SSDGolfTracker.py

Definition
This is a module that contains all my main code. This includes the front-end code
such as user interfaces as well as the back-end code such as the logic needed to
calculate yardages based off user data and current wind speeds.

emailcount.txt

This file contains the number of accounts created in my program. This allows the
software to know how many emails exist in the data base which makes it easier
to sort and append emails to the database when a new user creates an account
in my program.
A JSON file containing all user data such as user emails and encrypted
passwords. This file also contains the distances that the user enters the software
regarding each golf club they use. This ensures that the user won’t have to input
their distances each time they log in to my program.

database.json

*Hole1*.png …

Distance1.txt

This is the google earth images of each hole of the course that is placed within
the user interface. They can interact with this image and place a pin on where
they are on the specific hole. They will then be able to see how far they are from
the green. The user will also be recommended a club to use based off live wind
speeds and the distances they originally entered into the software. I have edited
these pictures to my liking using photoshop to outline the green and tee boxes.
This contains the distance of the point that the user has drawn in the software. It
is stored in the text file as it needs to be updated live when the user draws a
different line that equates a different distance.

Record layout and creation
For this project I specifically opted for JSON files to store my user data. This JSON file acts as a
database for my entire project. I chose a JSON file module for multiple purposes. Firstly, it can
permanently store data that was entered into the program by the user. This meant that when the
user logged back into the program at a different time, their data would be saved. Furthermore, this
program will be kept locally on my computer meaning that I don’t need an online database. This
means that using a JSON file layout was appropriate for my project.
Furthermore, I am using Python dictionaries to temporarily store inputted user data such as
distances. This means that when the distances need to be applied to the algorithm, they are simply
just pulled from the Python dictionary. The use of dictionaries will make my program more efficient
and effective. I am choosing both of these structures as I am familiar with them from previous
projects and know that I am able to use them productively because of their flexible and adaptable
frameworks.
An example of these structures can be observed in my user creation algorithms. As seen in the
pseudocode below, the data is placed in a dictionary and then appended to an external JSON file.
This algorithm has two different modules being the email and password:

17

BEGIN function login(): #Starts the function to begin to login algorithm.
global number
set number to -1
open database.json file in read mode as ff
load the JSON data from ff into data variable
for i in range(email_number):
set check_email to data["userdata"][number + 1]["email"] #Linear searches for each email
set check_password to data["userdata"][number + 1]["password"]
increment number by 1

hash the user password using the SHA256 algorithm and store it in password_0

if check_email = the user input email and check_password = password_0:
create a GolfTracker window and store it in login_window
show the login_window
close the current window

END function login():

with open('emailcount.txt', 'w') as reader:
reader.write(str(email_number))

function write_json(data, filename="database.json"):
with open(filename, "w") as f:
write data as JSON to the file with indentation of 4 spaces #Writes email to the JSON database

with open("database.json") as json_file:
load JSON data from json_file into data variable
store "userdata" in temp variable
create a dictionary y with "email" set to email_create and "password" set to
hashed_create_password

18

append y to temp #Unhashes password in the data base to compare with user entered password
write the updated JSON data to the database.json file using the write_json function

Algorithm design: Structure charts

Algorithm design: Pseudocode for main modules:
I am using multiple different algorithms whilst developing the solution to my problem. The most
common algorithms are linear searching methods that will sort through the different club distances.
Furthermore, I am using a binary searching algorithm to search through the data I pull from the
weather API and to filter out specific data that I want to use such as wind speeds and directions.
Below is the pseudocode for my Hole1 module. This is practically the same code for each golf hole
meaning that only one holes code is necessary to show the algorithm design. The purpose of this
module or class is to graphically display each golf hole whilst allowing the user to drag and drop a
line from where they are teeing off from, to where they want the ball to go. The program will then
recommend the user a club to use based off the distances they entered into the program.
Furthermore, the algorithm will account for live wind speeds and their direction at that specific time.

19

PSEUDOCODE for Hole 1 Init Algorithm:
BEGIN ALGORITHM
SET scene to new QGraphicsScene with self as argument
SET view to new QGraphicsView with scene and self as arguments
SET pixmap to QPixmap with self.image_path as argument
ADD pixmap to scene
SET view scene rectangle to QRectF with pixmap rectangle as argument
SET view horizontal scroll bar policy to ScrollBarAlwaysOff
SET view vertical scroll bar policy to ScrollBarAlwaysOff
SET view fixed size to pixmap width and height
SET self fixed size to pixmap width and height
SET global variable distance to 0
CREATE new QLabel with "Distance : " concatenated with string representation of distance and self
as arguments
MOVE distance QLabel to (10, 5)

CREATE new QLabel with "Wind speed: " and self as arguments
MOVE wind_speed QLabel to (10, 25)

CREATE new QLabel with "Wind direction: " and self as arguments
MOVE wind_direction QLabel to (10, 45)

SET global variable recommended_club to an empty string
CREATE new QLabel with "Use:" concatenated with string representation of recommended_club and
self as arguments
MOVE club_recommendation QLabel to (10, 65)
SET club_recommendation fixed width to 200
SET club_recommendation style sheet to "font-weight: bold; color: white;"

SET url to BASE_URL concatenated with "appid=" concatenated with API_KEY concatenated with
"&q=" concatenated with CITY #API algorithm to extract specific wind data.
20

SET response to the JSON response from a GET request to url
SET wind_speed_var to the value of the 'speed' key in the 'wind' dictionary in response #Extracting
specific wind speed data from the array of weather data
SET degrees to the value of the 'deg' key in the 'wind' dictionary in response #Extracting specific
wind direction data from the array of weather data
SET wind_speed QLabel text to "Wind speed: " concatenated with string representation of
wind_speed_var and "m/s"
SET wind_speed QLabel fixed width to 200

#This algorithm sorts through the wind direction in degrees and converts it to a compass direction
IF degrees is greater than or equal to 337.5 or less than 22.5, SET wind_direction QLabel text to
"Wind direction: N"
ELSEIF degrees is greater than or equal to 22.5 and less than 67.5, SET wind_direction QLabel text to
"Wind direction: NE"
ELSEIF degrees is greater than or equal to 67.5 and less than 112.5, SET wind_direction QLabel text
to "Wind direction: E"
ELSEIF degrees is greater than or equal to 112.5 and less than 157.5, SET wind_direction QLabel text
to "Wind direction: SE"
ELSEIF degrees is greater than or equal to 157.5 and less than 202.5, SET wind_direction QLabel text
to "Wind direction: S"
ELSEIF degrees is greater than or equal to 202.5 and less than 247.5, SET wind_direction QLabel text
to "Wind direction: SW"
ELSEIF degrees is greater than or equal to 247.5 and less than 292.5, SET wind_direction QLabel text
to "Wind direction: W"
ELSEIF degrees is greater than or equal to 292.5 and less than 337.5, SET wind_direction QLabel text
to "Wind direction: NW"

OPEN distance1.txt file in read mode and assign the list of stripped lines to distance_int
SET distance to the float value of the first item in distance_int #constantly checks this file for new
entry’s so it can update distance values instantly while the program is running.
CREATE new QTimer
CONNECT timer timeout signal to update_label method
START timer with 100ms interval #Checks the text file for a new entry every 100ms

CREATE new QPushButton with "Back" as text and self as argument

21

MOVE back QPushButton to (5, 820)
SET back QPushButton style sheet to "background-color: red; color: white;"
CONNECT back QPushButton clicked signal to back1 method

CREATE new QPushButton with "Next Hole" as text and self as argument
MOVE next_hole QPushButton to (335, 820)
SET next_hole QPushButton style
END

PSEUDOCODE for mouse events on the hole 1 class:
BEGIN ALGORITHM
OnMousePress(event)
if event.button() equals to LeftButton then
if not self.pin then
x = event.pos().x()
y = event.pos().y()
self.pin = Pin(x, y)
scene = self.centralWidget().scene()
scene.addItem(self.pin)
else
self.line_start_point = event.pos()
self.pin_pos = event.pos()
else if event.button() equals to RightButton then
distance = 0
open file named 'distance1.txt' with 'w' mode as f
write '0' to f
if self.line then
scene = self.centralWidget().scene()
scene.removeItem(self.line)
self.line = None
self.line_start_point = None
22

KeyPressEvent(event)
if event.key() equals to Key_Space then
if self.pin then
scene = self.centralWidget().scene()
scene.removeItem(self.pin)
self.pin = None
self.pin_start_point = None

OnMouseMove(event)
if self.line_start_point then
if not self.line then
scene = self.centralWidget().scene()
self.line = scene.addLine(self.line_start_point.x(), self.line_start_point.y(),
event.pos().x(), event.pos().y(),
QPen(Qt.white, 2, Qt.SolidLine, Qt.RoundCap, Qt.RoundJoin)) #Creates the line and coordinates that
is drawn from a mouse movement.
else
self.line.setLine(self.line_start_point.x(), self.line_start_point.y(), #Gets the coordinates from the
start of the line and the end of the line in order to calculate distance in meters
event.pos().x(), event.pos().y())

OnMouseRelease(event)
if event.button() equals to LeftButton then
if self.pin and self.line then
x2 = event.pos().x()
y2 = event.pos().y()
distance = ((x2 - self.pin_pos.x())^2 + (y2 - self.pin_pos.y())^2)^0.5 * 0.1659 #Distance formula
calculation to convert pixel coordinates to meters
distance3 = round(distance)
open file named 'distance1.txt' with 'w' mode as reader
write rounded distance value to reader
try
23

distance3 = round(distance)
except ValueError then
display a warning message box with title 'Invalid Distance' and message 'Please enter a valid
distance.'
Return
if distance3 is less than 40 then
set self.club_recommendation text as "Use: a soft sand wedge"
return

clubs = {
'Driver': driver_distance,
'3 Wood': three_wood_distance,
'4 Iron': four_iron_distance,
'5 Iron': five_iron_distance,
'6 Iron': six_iron_distance,
'7 Iron': seven_iron_distance,
'8 Iron': eight_iron_distance,
'9 Iron': nine_iron_distance,
'Pitching Wedge': pitching_wedge_distance,
'Sand Wedge': sand_wedge_distance
} #Dictionary of all clubs and their values of user inputs
recommended_club = None
distance_diff = 1000
for club, max_distance in clubs.items() do
if int(max_distance) - distance3 is less than distance_diff and int(max_distance) - distance3 is
greater than or equal to 0 then #If statement that recommends a club to the user based off
distances and max distances for each club
set distance_diff as int(max_distance) - distance3
set recommended_club as club

if recommended_club then

24

if distance_diff is greater than or equal to 4 then #If the distance is 4 meters shorter than the
recommended club, the program will suggest to hit the club softer
set self.club_recommendation text as "Use: a soft {recommended_club}"
else
set self.club_recommendation text as "Use: {recommended_club}"
else
set self.club_recommendation text as "You should use a driver”
END

Test plan
My initial test plan is to test the boundaries of my software interface and see if each module works
as it was programmed to do. The first test I am going to run is to see if my login character boundaries
work. If my method is correct, it should only allow accounts that exist in the database already to log
into the software and navigate through the different menus. If the user enters a username and
password that aren’t in the database, they should be denied entry into the software. However, if the
user creates an account and then uses those details to login to the software, it should let them as
the created account is appended to the JSON database. Furthermore, in the planning process I have
used stubs to ensure that each module works like it was designed to. Each time I add a new module
or update the system, I will test the software in its entirety to ensure that I could resolve all the
errors as early as possible. Each time I add a new menu or user interface, I will have my target
audience (my golf friends), test the software and give me feedback accordingly. Lastly, I will do
multiple load tests with my software to ensure that it won’t crash even when the systems CPU and
GPU are under significant utilisation/load. My test plan will go as the following:
x

x

x

Module testing: I will test each module for functionality before it is integrated into the
system. For the menu of my program, I will use a top-down approach and implement
temporary stubs to take the place of the main modules of my code. I will also implement
white box testing to monitor variables during this process. This will ensure that my main
menu effectively calls the right classes. However, whilst testing my main golf hole modules, I
will be using a bottom-up approach with the implementation of drivers. This will allow me to
artificially call the method without having to navigate through the main menus to do so.
Integration testing: Once all my modules are complete, I will integrate them into the system
chronologically. This will ensure that all my modules work symbiotically within my program
when it is complete.
Program testing: I will then use program testing to check overall functionality of my solution.
I will manually develop valid, erroneous and boundary test data. For the valid data, I will
enter in a username and password that is longer than 8 characters. This should be accepted
by my program. For my boundary data, I will enter in a username and password that is 8
characters (lower limit) and 20 (upper limit) characters long. These should also be accepted
by my program. For the erroneous data, I will enter in a username and password shorter
than 8 characters or longer than 20 characters. This should not be accepted by my program.
Furthermore, when a user enters in distances for each club my valid data will be any integer
greater than 1 (lower limit) or any integer less 400 (upper limit). My program should accept
25

this data. My boundary data is 1 and 400, this should be accepted by my program. My
erroneous data is any number less than 1 or greater than 400. This should not be accepted
into my program. Additionally, the distances text box doesn’t allow the user to enter a string
so I will not have to test for this. A table of this test data is below:
Login interface inputs:
Distance interface inputs:
Valid data
15 characters
253
Erroneous data
3 and 21 characters
423 and - 1
Boundary data
8 and 20 characters
1 and 400
x System testing: I will test different types of hardware and software to ensure that my
program operates on a wide range of devices and environments.
x Stress testing: This will not be applicable for my software as it is a local program that only
allows for one user at any given time.
x Post implementation review: Once my software is complete, I will implement a post
implementation review to affirm the degree of success from the project. This will also allow
me to see the extent to which it has met its objectives outlined in the defining the problem
section. This will allow the client to present any issues that they may have with the software,
allowing me to resolve them or add them to the maintenance schedule.
Test
No.
1.1

2.1
2.2
2.3
3.1
3.2
3.3
4.1

4.2

4.3

5.1

Test description

Test data

Expected outcome

Username and
encrypted password
append to JSON
database.
Entering username
Entering username
Entering username
Entering distances
Entering distances
Entering distances
Right mouse drag draws
a line in Hole*number*
class

Coreyporter85@gmail.com
12345678

Appends user data to
database.json

Abc
Abcdefghijklmnopqrstu
Corey1234567891
-1 (m)
423 (m)
253 (m)
Hold down right click and
drag

Not valid, re enter
Not valid, re enter
Accepted
Not valid, re enter
Not valid, re enter
Valid
Should draw a line from where
the user has started the drag to
when the user has released the
right mouse button.
This should remove the line so
a user can make a new one

Right mouse click
should remove a
previously drawn line in
Hole*Number* class
The user can place and
pickup the pin location
when pressing space
bar

Right click mouse button
when a previously drawn
distance line is on screen.

When the user draws
their distance line it
should given them an
accurate distance in
meters of the length of

Draw a line a golf hole and
print the distance of the
line.

Hover mouse curser over
where the user wants to
drop the pin and press the
space bar.

The software should place the
pin under the users curser
location on the graphical golf
hole image. When the user
presses the space bar it should
pick the pin back up.
The program must give an
accurate club recommendation
and direction to aim based on
the inputs and live wind speed.
I will test this in google earth
26

6.1

6.2

the line as well as an
accurate club
reccomendation
Press the “track game”
button that leads to the
first hole of the golf
course selected.
Press the “save
distances” button that
should append user
distances to a dictionary

Clicking the button with a
left mouse click

Clicking the button with a
left mouse click

pro where you can accurately
measure the distance of
specific lengths on each hole.
The software should take the
user to a different window that
displays the first hole of the
golf course they selected.
The software should append
the distances for each club that
the user has entered into a
data dictionary that can be
read by the algorithm for the
club recommendation module.

Enabling and incorporating feedback from users at regular intervals
I am regularly seeking feedback from potential users throughout my development process. These
users are generally my friends that I play golf with. Thus far they have given me accurate feedback
that I am able to implement into my program to maximise usability for all users. From this current
feedback I was able to refine the layout of my user interface and received suggestions to improve
the front-end graphical layout of the hole images. I went on to blur out sections that will act as a
boundary around each hole in Adobe Photoshop as well as making an outline around the green and
tee box. This has made my program easier to use as the user is able to graphically view the sections
and boundaries of each hole. Furthermore, advice from Mr Fryer gave me the idea and expertise to
implement a JSON database. This is the first time I have ever used JSON and his feedback and
expertise is significantly guiding me through this process and has overall improved my program so
far.

Use of CASE Tools
During the development process I have used many different Computer Aided Software Engineering
(CASE) tools. The most common one I am using is LucidChart which aided me in the production of my
documentation for the different charts I am creating such as dataflow diagrams and structure charts.
Furthermore, I am using Microsoft Excel to create my Gantt Chart which I am referring to constantly
throughout this development process. For software version control I am using GitHub where I am
committing all the milestones of my project to a repository just in case my code breaks. This means I
can roll back to previous versions and prevent the issue from occurring. Lastly, to produce my code I
am using the VSCode IDE.
GitHub link: https://github.com/CoreyPorter5/SDD-Major-Project---Corey-Porter

27

Implementation
Tools and modules used:
To implement my solution, I have used multiple CASE tools to aid me in developing and
documenting. I have used Google Earth Pro to take birds-eye snapshots of each golf hole. I then
imported these images into Adobe Photoshop to outline each tee box and green. This aids the user
visually in seeing where they hit from and where to aim. It will also assist individuals with eyesight
issues. Furthermore, I used the blur tool in Photoshop to outline the hole, making it even easier for
the user to get a scope of where to hit, especially if they have never played the golf course before. I
used LucidChart as a case tool to create my structure charts and context diagrams for
documentation. This assisted me through its large collection of icons and processes’. The libraries I
have used are listed below:
Module/Library
PyQt5

Hashlib

JSON

What is it?
This is a python library for
creating generated user
interfaces (GUI) using the Qt
toolkit.
This is a module in Python that
provides a suite of functions
for having data such as
passwords.
This is a text-based way of
representing arrays and scalar
data.

Requests

This library can be used to
scrape the data from a website
using an API.

Datetime

This supplies classes for
manipulating dates and times
within a python program.

OS

This library provides functions
for creating and removing a
directory and fetching its
contents.

Why have I used it?
My program is mainly
compromised of user
interfaces meaning that PyQt5
would aid me in creating these
I needed to encrypt user
passwords to protect their
data in my database. I used
hashlib to achieve this.
JSON is easy to read and write
from. Because of this, I stored
my user database on a JSON
file so it could be updated and
read in real time.
I needed to extract live wind
speeds and directions for a
weather API. This meant that I
used the requests library to
pull this data and interpret it.
In my software I needed to
constantly refresh text-boxes
to display live data that is
constantly updating. I used a
timer to achieve this as after a
certain amount of time the
variables would be updated.
This would fetch external files
needed to assist my program
such as the images of each golf
hole.

I have used Object-oriented programming to structure my software so that properties and behaviour
are bundled into individual objects. I have achieved this by using different classes within my
software that run different methods within the context of the object that calls it. An example of this
28

is my HoleOne() class, which involves different methods to calculate the distance, allowing the user
to draw a graphical line from one coordinate to another and displaying live weather data pulled from
an API constantly updated through a time module.

Data dictionary (Final)
Data ID
Email_number

Self.username_input

Self.password_input

Check_email

Hashed_password

Data

Course_selector

Self.*club name*_input

Hole1

Type
The amount of email
address. In the format of a
string. Imported as a text
file.
The user inputted email
address. In the format of a
string. Exported to a JSON
file.
The user inputted password.
In the format of a string.
Exported to a JSON file after
it is encrypted.
Cycles through all email
addresses in the JSON file to
find a match. Uses a linear
searching algorithm.
This variable stores all
hashed or encrypted
password after it has been
encrypted using the
hashlib.sha256 library.
Imports the user information
from the JSON file and
appends new email
addresses to the data base.
Holds the string of the
course that the user has
selected to play at. They
choose this through the
software.
This variable stores the data
of each club distance that
the user has inputted within
the software. This is stored
as an integer
Holds the image of the
specific hole that the user
chooses to play at. The user
can then interact with the
image and drop a pin as to
the current location of their
ball

Format
Emailnumber = 5

{“username”:
coreyporter85@gmail.com}

{“password”: “asdjkgA@#fjhf”}

For i in range(email_number):

{"password": "506dba0dbc9f9654caf2d
272783262403943f1e38a98a9a6b998ba
39a3d00dca"}

Data = json.load(json_file)
Temp.append(data)

“Bondi Golf Course”

234 (meters)

29

Check_password

Distance

Clubs

URL

Response

Wind_speed_var

Club_recommendation

Global_*clubname*

This is stored as an array of
user data, email count and
the password that the user
has entered.
A Float that contains the
data of the distance that is
calculated using the
Euclidean distance formula.
This is the distance from one
part of the image to another
part of the image. It
converts pixel coordinates to
meters using this formulaic
algorithm
This is a data dictionary that
contains the values of the
distances that the user has
entered into the software.
These distances will then be
considered when the
software recommends a club
for the user to use.
This contains the raw data as
an array from the live
weather data from an
OpenWeather API.
This is the response of the
live API and the data is
requested and then placed
into a JSON file.
This pulls the specific data or
wind speed in this case from
the array of weather data
from the API. It then saves
just the wind speed as a
float in this variable which is
called multiple times
throughout my software.
This variable stores the club
recommendation based on
the distance is from their
target and their club
distances that they have
inputted
This stored the distance of
each variable in a global
variable meaning that its
data was able to be used
throughout each class and
module.

["userdata", number + 1, "password"]

Distance = ((x2 – self.pin_pos,x())**2 +
(y2 – self.pin_pos.y())**2)**0.5 *(The
multiplier which is calculated at a later
time as each image or hole has a
different pixel dimesion meaning the
scaling is different each time.)

Clubs = {
‘Driver’: driver_distance,
‘3 Wood’: 3_wood_distance,
….
}

Url = BASE_URL + “appid=“ + API_KEY +
“&q=“ + CITY

Response = requests.get(url).json()

Wind_speed_var =
response[‘wind’][‘speed’]

if int(max_distance) - distance3 <
distance_diff and int(max_distance) distance3 >= 0:
distance_diff = int(max_distance) distance3
Club_reccomendation = club
Global_six_iron_distance =
six_iron_input.text()

30

Distance_int

Self.line_start_point

Image_path

This variable contains the
distance of the line that the
user has drawn as an integer
opposed to a string. This
means that the distance can
be appended to the text file
and displayed graphically for
the user.
This is the pixel coordinates
of the start of the distance
line that the user draws. This
then goes into the algorithm
that calculates the distance
of the line in meters.
This contains the png image
of each hole and allows this
image to be interchanged
when the user selects a
different hole.

with open('distance1.txt', 'r') as reader:
distance_int=[line.rstrip('\n') for
line in reader]
distance = (float(distance_int[0]))

self.line_start_point = event.pos()
self.pin_pos = event.pos()

def nexthole(self):
self.hole_2 =
HoleTwo(image_path="hole2.png")
self.hole_2.show()
self.close()

Solution testing and improvements
The main feedback I received was that the pins of the golf course changed every day, meaning there
was no way to aim at the hole accurately. To fix this, I added an option where the user could place a
green dot on the green, which would symbolise the pin location. This meant the user wouldn’t have
to walk up to the green and physically remember where the pin location was, as the improvement
allowed the user to place the green dot permanently until they right clicked, which would remove it.
Additionally, further feedback was that my software should display the wind speed and direction on
the screen so the user could get a scope of how severe the winds were (in m/s) and what direction
they were facing. I placed a QLabel under the distance text with wind speed and direction to fix this.
This was on each hole’s graphical interface. However, the API I was using had the wind direction data
in degrees, and after talking to a few potential users, they suggested I display the wind direction in
compass bearings. I then coded a simple degree-to-bearing algorithm to resolve this.

Test plan
Module testing: I tested each individual module separately with the test data I discussed previously.
Below are the results of these tests:
Test No.
1.1 Database.json

Actual outcome
This passed the test
flawlessly. When I
created an account on
the system, I opened the
JSON file and it was
appended in an array
format. Rather than it
showing the users
password that they used

Evidence of testing
Appended JSON
file database in an
array data
structure

Changes made
N/A

31

2.1 - main.py - entering
username

2.2 – main.py –
entering username

2.3 – main.py –
entering username

3.1 – main.py –
entering distances

3.2 – main.py –
entering distances

to create the account, it
showed their encrypted
password. Success.
This passed the test
perfectly as well. When I
create an account and
choose “ABC” as my
username it was denied
as it didn’t reach the
character requirements
This passed the test.
When I created an
account and choose
“Abcdefghijklmnopqrstu”
as my username, it was
denied as it didn’t didn’t
reach the character
requirements.
This passed the test.
When I created an
account and chose
“Corey1234567891” as
my username, it was
accepted as it fulfilled
the character
requirements
This passed the test as
when I entered “-1” as a
distance for any club, it
wasn’t accepted as it
didn’t fit within the
boundaries of what
numerical value I could
enter.
This didn’t pass the test
as when I entered “423”
as a distance for any
club, it was accepted and
added to the “clubs”
dictionary even though it
exceeded the value limit.

My account wasn’t
appended to the
JSON user
database

N/A

My account wasn’t
appended to the
JSON user
database

N/A

My account was
appended to the
JSON data base
allowing my to log
in with those
details.

N/A

That distance for
my club wasn’t
appended to the
“clubs” dictionary

N/A

The distance was
appended to the
“clubs” dictionary.

To fix this I had to add
a line of code that
would prevent the
distance from being
appended to the
dictionary that held
the distance values of
each club. This
involved me using an
if statement that
stated that if
club_distance > 400
do not append to
dictionary and ask
user to re enter.

32

3.3 – main.py –
entering distances

4.1 – main.py – mouse
movements

4.2 – main.py – mouse
movements

This passed the test as
when I entered “253” as
a distance for my club it
was accepted and added
to the “clubs” dictionary
as it was within the value
limit.
This passed the test as
when I went to draw my
distance line on the hole,
it graphically displayed a
line that anchored to
where I initially right
clicked and finished
when I released the right
click.
This did not pass the test
as I got a runtime error
when I pressed the right
click on my mouse to
remove a previously
drawn line.

4.3 – main.py – mouse
movements

When the user pressed
the space bar, it allowed
them to drop and pickup
the pin location
successfully. This was
represented by a green
circle that could be
placed anywhere on the
screen.

5.1 – main.py –
distance calculation

When the user draws the
line, it displayed the
distance of the line in
meters and the club
recommendation based
on the value of that

The distance was
appended to the
“clubs” dictionary.

N/A

The line was
graphically drawn
on the screen that
would act as the
distance line.

N/A

I received a run
time error that
crashed my
program.

To fix this I had to
implement an
algorithm that would
detect that a line was
drawn and clear the
screen of any
“drawings” when the
user right clicked.
Furthermore, if there
was no line drawn and
the user right clicked,
I added a method that
would ensure that
nothing would
happen as there was
nothing to clear from
the screen.
N/A

The green dot
appeared under
the mouse
location when the
space bar was
pressed and was
removed when the
user pressed the
space bar again
despite where the
mouse location
was on the screen.
This was successful
as it displayed the
correct distances
and club
recommendations
in the corner of

N/A

33

distance. These were
displayed in the top left
of the screen as it didn’t
impede on the graphical
view of each hole.

6.1 – main.py –
pressing the track game
button

6.2 – main.py –
pressing the save
distances button

When I pressed the track
game button, it
successfully took my to
the menu where I could
pick what hole I wanted
to play on at the course I
have selected.
When I entered the
distances for each club
and pressed the save
distances button, they
did not successfully
append to the “clubs”
dictionary.

the screen. I
checked these
distances with
google maps and
they were
accurate within
1.2m each time.
It closed the
original window I
was on and
opened another
window with the
golf hole selected.
No club distances
were appended to
the “club”
dictionary.

N/A

To fix this, I made sure
to save each distance
into a variable when
the user pressed the
“save distances”
button. These
variables would then
be appended to the
dictionary and
changed from a string
to an integer.
Originally, I appended
the raw distances to
the dictionary which
didn’t work as they
were not saved into a
global variable and
were therefore
unable to be
appended to the
dictionary.

Integration testing:
After creating my modules, I integrated them into the system, and this was successful as I ensured
that they would work symbiotically within my system before combing the modules together.
Program testing:
Once I integrated the system, I conducted program training. Whilst doing this, I discovered that my
program was using the hard-coded stub data that I originally placed into the modules so I wouldn’t
have to enter each distance every time I ran the program. However, once I removed the stubs from
my system, it took the live user data and implemented it into the algorithms I had coded.
System testing:
I tested my program on two different systems. That included my Mac laptop and my Windows PC.
Both systems were able to handle my program and run it effectively and inefficiently. There were
34

also no cross-compatibility errors with the Windows and MAC operating systems as they were both
64 Bit.

Post-implementation review:
Once I finished coding my solution, I got some friends to play around with the system. I then gave
them my system requirements list so that they could check that my program met the client’s needs.
This was successful, and out of the six friends I asked, they all stated that I fulfilled each
requirement.

System and User documentation
The documentation within my code was provided with comments. I made sure to comment on each
algorithm and function with a clear name and accurate description that states the overall
functionality. Evidence of this can be seen in my full code listing and pseudocode. If I encountered
any bugs, logic errors or runtime errors, I was able to find what module was causing these errors
through the comments. This significantly aided me in creating my solution as I was able to
manoeuvre around my code much more efficiently.
I also created a README.md file to aid new users using my program. This file contains a system
overview as well as the functionality of the program and what it does. This file is placed in my GitHub
repository; however, I have linked screenshots below. I have also created an online tutorial that is
linked in my software’s online help option that walks the users through the menus and functionality
of my program. The link to the online tutorial is: Online Tutorial
Lastly, I have made an installation guide to aid users in installing my program into any software
environment. The link for this is: Installation Guide

READ ME file on GitHub Repo
35

Evidence of regular communication with stakeholders
In my logbook, I have recorded the dates I communicated with potential users of my program. These
included possible users such as classmates, friends, and Mr Fryer. In my logbook, my meetings with
stakeholders also showcase the ideas and suggestions I received. This logbook can be found in the
appendices of my program.

Evidence of online help
My software solution has a help button on the top right of the main GUI. When the user interacts
with this help button, they will be brought to a page that displays the user manual and any help tips.
This should aid the user in interacting with my program and answer any questions they have about
the software solution. A screen of the online help is below:

Online Help User interface

36

Evaluation/Maintenance
Testing of user requirements
After checking all of user requirements and evaluating my software solution, I can conclude that my
program has alleviated the hole in the market of free and effective virtual golf trackers. My program
runs natively on appropriate resolutions with no stuttering issues or crashes. Furthermore, it gives
an accurate club recommendation within plus or minus 1.3 meters. I have concluded that this is
accurate enough. Furthermore, the program has achieved my must have functionality elements. This
includes having a local database that stores user data and allows for a new account to be appended,
a function that allows the user to choose what hole they are playing on and an active API that takes
live wind speeds and considers them in the distance algorithm.
However, my program is limited by the fact that it only has one golf course. I aim to improve this in
future versions of my software by iterating through another software development cycle.
Furthermore, I didn’t add a GPS tracking feature due to hardware limitations. I may also implement
this in a future version of my software solution depending on changing client requirements.

Feedback
User Feedback:
The buttons are inconsistently
sized and not centred.
The program slows down
when I draw too many
distance lines in a short
amount of time.

The program lacks a score
tracking option

The colour of the font in the
distance tracker is hard to see.
The tracker should allow users
to compare rounds and
distances with other users
through an online database.

Improvement, implemented or planned:
I have altered the CSS within my program to fix this issue. The
buttons are now evenly sized with appropriate spacing and in line
with each other.
After considering why this issue may exist, I concluded that my
timing module was refreshing the distance variable every 0.0001ms.
This meant that the program would slow down over time as the
timer was looking for a new distance in an extremely short amount
of time. This would make my program slower over time. To fix this I
changed the clock to refresh the variable every 0.5 seconds. This
prevented my program from slowing down as the timer wasn’t
placing as much stress on the hardware.
This has been added to a future development cycle under the agile
methodology. This is a high priority improvement however I was
unable to complete this during the duration of this project due to
deadlines.
This feedback has been implemented into my software by changing
the colour of the distance text from black to white. This stood out
much more on the background so it was easier for the user to see.
This feedback has been considered and planned meaning it will be
iterated in future developments of the software solution. This is
because I don’t have enough time in my first software development
cycle to implement an online database as I currently have a local
database. However, this has been considered as a high priority task.

37

Evaluation of Ethical and social considerations
Privacy:
The first ethical and social consideration I outlined was a potential data and privacy breach I would
have to prevent in my software solution. I achieved this as I stored my user data within a JSON
database. Furthermore, user data, such as passcodes, were encrypted using the SHA-256 Python
library. This ensured that my user database was completely secure, as it was practically impossible
for a hacker to see user passwords. Furthermore, my program does not ask for personal user data
such as DOB, credit card information or residential address. This ensured that I achieved my social
and ethical considerations regarding privacy.

Inclusivity:
The second ethical and social consideration I initially outlined was inclusivity for visually impaired
users. To maximise my software’s usability for all users, I researched specific colour patterns that
were easier to see for individuals will imperfect vision. I then implemented this into my software
solution. An example of this is the white background and the black body text that sticks out and is
easy to read. Furthermore, I can conclude that my program is completely free with no additional
costs, meaning there are no economic barriers to entry. After receiving user feedback about the help
button, I eventually changed it from “help” to “?”, making it more recognisable in different cultures.
Unfortunately, I couldn’t add keyboard navigation options within my software for disabled users.
However, this has been deemed a high-priority task in my next software development cycle. Overall,
I evaluate the social and ethical considerations regarding inclusivity as a large success.

Hardware issues:
I am able to conclude that my software can run on systems at 1920 x 1080 screen resolution with at
least 4GB of DDR4 ram running at 2400mhz, a 2-core, 2-thread central processing unit (CPU) and a
discrete graphics processing unit (GPU). After testing my program on a system with similar
specifications to the ones previously mentioned, CPU load was only at around 20 – 40% usage over a
10-minute period. Furthermore, the program uses around 2GB of ram. I have linked a photo below
of this data. A large majority of systems in 2023 have hardware much more powerful hardware
specifications than the ones I have listed as the minimum requirements. This means that my
software solution should be able to run on any system comfortably. This means I have achieved my
social and ethical considerations regarding hardware limitations.

CPU and RAM usage whilst running my program

38

Intellectual Property:
NSW IP laws protect my program as it is designed in an approved school environment. This means I
didn’t have to worry about protecting my software.
Overall:
Based on my assessment, I can confidently state that I successfully addressed all social and ethical
concerns encountered throughout the entire process of designing, developing, and testing my
solution. Considerations I couldn’t implement into this version have been considered and will be
added to the updated version in the future.

And I went to the le mona de stand and sta nd.

And I went to the le mona de stand and sta nd.

And I went to the le mona de stand and sta nd.

And I went to the le mona de stand and sta nd.

And I went to the le mona de stand and sta nd.

And I went to the le mona de stand and sta nd.

And I went to the le mona de stand and sta nd.

And I went to the le mona de stand and sta nd.

And I went to the le mona de stand and sta nd.

And I went to the le mona de stand and sta nd.

And I went to the le mona de stand and sta nd.

39

Appendix
Project logbook
12:11 pm 3/2/2023 – Created Logbook Journal
2:12 pm 5/2/2023 – Started documentation.
2:33 pm 5/2/2023 – Finished identification of the problem section
2:43 pm 5/2/2023 – Finished communication to establish requirements section
3:09 pm 5/2/2023 – Finished idea generation section
3:26 pm 5/2/2023 – Finished investigate alternative approaches to a software solution section
4:03 pm 5/2/2023 – Finished requirements list section
8:29 pm 5/2/2023 – Started developing project plan section
12:34 pm 7/2/2023 – Interviewed golfer Ed Proctor who gave me some advice on my solution and
idea.
4:19 pm 8/2/2023 – Sent out a survey to around 20 – 30 of my friends and golfers about what they
thought about a free golf tracker.
4:35 pm 9/2/2023 – Finished developing project plan section and finished my Gantt Chart
6:24 pm 11/2/2023 – Completely finished editing the define the problem section of my logbook.
5:12 pm 12/2/2023 – Started coding a prototype interface for the login page for my golf tracker
6:38 pm 12/2/2023 – Finished coding a prototype interface for the login page for my golf tracker
9:09 am 13/2/2023 – I received feedback on the prototype interface from a stakeholder who liked
the overall layout but suggested that I enlarge the size of the buttons and use CSS styling to create a
more user friendly GUI.
4:12 pm 14/2/2023 – Started coding the main user interface for my golf tracker, than allows the user
to choose a golf course and enter the ranges for their clubs
5:56 pm 14/2/2023 – Finished coding the main user interface and linked it with the initial login page
I coded earlier.
2:34 pm 19/2/2023 – Stared the Understanding User Requirements sections of the logbook and
completed design specifications.
3:56 pm 19/2/2023 – Completed data structures table and storyboard with relevant screens and GUI
that user should expect.

40

1:23 pm 21/2/2023 – Completed the IPO Chart, context diagram and initial structure chart
7:45 pm 23/2/2023 – Created a mock interface with stubs to test the functionality of the main menu
and how it may interact with the other software solution components.
5:54 pm 24/2/2023 – I received the feedback from the survey I previously sent out and collated all of
the results into a graphical pi-chart.
6:12 pm 27/2/2023 – Finished the limited prototype development section and took screenshots of
the user interface prototype I had coded earlier. This will be the template for my final software
solution.
9:34 am 2/3/2023 – Finished the social and ethical issues sections meaning I have finished the
understanding user requirements section. I submitted this for feedback from my teacher.
2:26 pm 7/4/2023 – Mr Fryer’s feedback was to add small tables with my data structures such as the
JSON file. I implemented this into my project documentation.
4:59 pm 11/4/2023 – Began the Planning and Design section. I finished the interface design by
drawing what I wanted my GUI to look like. Furthermore, I also finished the selection of software
environment section. This outlined what language and IDE I was using. It also made me consider the
different operating systems that my program should be able to run on.
6:23 pm 11/4/2023 – I finished the identification of appropriate hardware section as well as my
initial data dictionary.
9:47 am 15/4/2023 – I finished the definition of required validation processes section. Furthermore,
I also finished coding all of the user interfaces and linked them together with drivers and stubs. I am
yet to code the logic for these interfaces.
11:32 am 19/4/2023 – I finished the definition of the files that I would use for my software solution.
Furthermore, I finished the record layout and creation section meaning that it was time for my to
start planning the logic I would use for my main modules in either pseudocode or python.
9:58 pm 27/4/2023 – I finished coding the JSON database for my software. This allowed the user to
create an account and for it to be appended to the database. Once the user created the account,
they were able to login to the software and navigate through the menus.
10:43 pm 29/4/2023 – I created pseudocode for this module and implemented it into the record
layout and creation section.
4:32 pm 30/4/2023 – I created the structure chart for my golf hole class. This will be used to aid me
as I begin to code this module.
8:53 pm 31/4/2023 – I created the pseudocode for the golf hole 1 init algorithm as well as the
mouse events on the hole 1 class.
3:17 pm 2/5/2023 – I finished the test plan for my software solution that included a table of all the
valid, erroneous and boundary data. Furthermore, I added test numbers for the different tests that I
will be conducting on my program once it is complete.

41

10:34 pm 3/5/2023 – I finished the enabling and incorporating feedback from users at regular
intervals section as well as the use of case tools. This meant I had fished the planning and design
section.
1:45 pm 5/5/2023 – I committed my project thus far to a GitHub repository. This will allow me to
keep a record of the different coding stages of my software solution.
2:19 pm 6/5/2023 – I submitted the planning and design section for feedback to Mr Fryer.
11:23 pm 19/5/2023 – I fixed a bug that prevented the user from entering a username more than 10
characters long.
5:35 pm 21/5/2023 – I finished coding the hole 1 logic for my program. I implemented this into my
menus and it worked as I expected.
4:03 pm 23/5/2023 – After allowing potential users to test my program thus far, they stated that I
should implement a feature that allowed them to mark the pin of each hole. I added this into my
program.
2:53 pm 29/5/2023 – I stated the implementation section of my documentation and finished the
tools and modules used section. I added a table to clearly identity the different libraries that I used
within my software solution.
2:45 pm 1/6/2023 – I met with a potential stakeholder of my software solution who tested my
program and provided me with a document of feedback. This included recommendations to change
the size of buttons, text and colours within my software.
3:21pm 3/6/2023 – I finished the logic for the code and edited my variable names so that they would
be more easily understood by outside developers. Furthermore, my code allowed the user to use all
nine holes of the golf course rather than one.
9:24 am 5/6/2023 – I started using photoshop to clearly create a graphical representation of each
hole.
5:07 pm 5/6/2023 – I finished photoshopping each hole. This involved me tracing out each green and
tee box in a black outline so it would be easier for users to see. Furthermore, I blurred out the edges
of each hole as a means to not confuse the user.
4:18 pm 6/6/2023 – I committed my updated and finished code to my GitHub repository to track my
development progress.
9:32 am 7/6/2023 – I finished the final data dictionary for my software solution. Furthermore, I
finished the solution testing and improvements section of the documentation.
7:49 pm 8/6/2023 – I finished the final test plan as I was happy with the product of my software
solution. I created a table to showcase my results and finding as well as to highlight any feedback or
changes that I had made.
10:23 pm 9/6/2023 – I fixed a bug that prevented the program from being able to count how many
email addresses were stored inside of the user data JSON file.

42

5:32 pm 10/6/2023 – I met with another potential stake holder who recommended that I adapt the
software so that it runs flawlessly on both Mac and Windows operating systems.
8:53 pm 11/6/2023 – I started the system and user documentation section. Furthermore, I created
an online tutorial that I uploaded to YouTube as well as an installation guide.
9:45 am 12/6/2023 – I created a ReadME.md file in my GitHub repository for any potential users or
developers.
3:57 pm 13/6/2023 – I finished the evidence of online help section and created a menu in my
software that allows the user to read through a document. This would likely answer any potential
questions that they may have.
6:35 pm 13/6/2023 – I finished the evidence of regular communications with stakeholders section.
11:45 am 16/6/2023 – Fixed a bug where the golf club recommendation was hard coded into the
software rather than having the updating variable in its place.
9:09 pm 17/6/2023 – I executed my program as an .EXE file on my Windows PC using the PyInstaller
module.
8:24 am 18/6/2023 – I submitted the implementation section to Mr Fryer for feedback.
10:23 pm 20/6/2023 – I began the evaluation section of my documentation and finished the testing
of user requirements.
7:19 pm 21/6/2023 – I completed the user feedback table that I received from 3 potential
stakeholders of my software solution. I represented their feedback as a table.
12:45 pm 23/6/2023 – I completed the evaluation of ethical and social considerations section of the
documentation where I referenced my previous social and ethical considerations section and
evaluated if I fulfilled these considerations in my final software solution.
7:11 pm 25/6/2023 – I submitted the maintenance section of my documentation to Canvas for
feedback.
10:13 am 7/7/2023 – I finalised the bibliography for my documentation using APA 6 referencing,
making sure to cite each source that aided me in creating my solution.

43

Surveys/interviews

A survey that I ran with around 20 – 30 potential users.

Full code listing
A full listing of my complete code for this project can be found at the repository: GitHub Repo

44

Record of communication:
March 6th and 7th: I met with stakeholder Ed Proctor and he gave me effective feedback on my initial
prototypes and overall functionality/idea through an email log that I have attached screenshots of
below:

April 3rd: I met with my teacher Mr Fryer who is a potential stakeholder in my software solution. I
told him that I was looking to code a JSON user data base but I had not much experience in doing so.
He and I then spent the next 1 – 2 hours working through the intricacies and complexities that is the
45

JSON data structure and he aided me through this process to create a successful outcome. He
further helped me implement a SHA-256 hashing algorithm for my software solution to prevent any
data breaches and protect user passwords in a secure manner.
May 25th: I had a meeting with another potential stakeholder of my software solution named Felix
Molly (my golf partner). He suggested that I include an option that allows the user to add a green
dot on the green where the pin would go. He drew me a possible design which I have attached
below. This guided me as I implemented this feature into my software development cycle.

Potential stakeholder Felix Molloy using my software

Felix Molloy’s sketch of the green pin locator I should add

46

June 17th: I met with stakeholder Ed Proctor once again with the finished result of the golf tracker
software. I let him play around with it for a while and he really enjoyed it stating, “let me know when
I can use this on the course”.

Backup Procedures:
Throughout this project, I have used committed different versions and milestones of my code to
GitHub. This has helped me save and track the latest versions of my code and allowed me to roll
back to previous versions. This was extremely useful when I was implementing the image of each
hole into the software, as I encountered a formatting issue where the images weren’t being
graphically displayed at their maximum resolution To fix this issue, I rolled back to a previous version
of my code that I committed to my GitHub repository and was able to troubleshoot and resolve a
functionality issue within one of my algorithms that only allowed the image to display at 200 x 200.

References

Archer, R. (2022, May 20). rlarcher/GolfTracker. GitHub. https://github.com/rlarcher/GolfTracker
How to append JSON to a .json file? (n.d.). Stack Overflow. Retrieved June 9, 2023, from
https://stackoverflow.com/questions/67904275/how-to-append-json-to-a-json-file

Matteo, J. (2022, January 25). Store Password Safely in Python. How to hash passwords using bcrypt
| Python in Plain English. Medium; Python in Plain English. https://python.plainenglish.io/storepasswords-safely-in-python-e38a8c0c8618?gi=43278a51fcc0

OpenWeatherMap.org. (2015). Weather API - OpenWeatherMap. Openweathermap.org.
https://openweathermap.org/api
PyQt5 - How to calculate corner points of a QGraphicsRectItem after rotation by its center
point? (n.d.). Stack Overflow. Retrieved June 9, 2023, from
https://stackoverflow.com/questions/69836755/pyqt5-how-to-calculate-corner-points-of-aqgraphicsrectitem-after-rotation-by

47

PYQT5 drawing line. (n.d.). Stack Overflow. Retrieved June 9, 2023, from
https://stackoverflow.com/questions/55078456/pyqt5-drawing-line

PyQt5 Tutorial - Drawing Shapes with QPainter Class. (n.d.). Www.youtube.com. Retrieved June 9,
2023, from https://m.youtube.com/watch?v=jMDpJ8x251s

Python, R. (n.d.). Python and PyQt: Building a GUI Desktop Calculator – Real Python.
Realpython.com. https://realpython.com/python-pyqt-gui-calculator/

QPainter — Qt for Python. (n.d.). Doc.qt.io. Retrieved June 9, 2023, from
https://doc.qt.io/qtforpython-5/PySide2/QtGui/QPainter.html

Real-Time ISS Tracker - 101 Computing. (2018, December 18). Www.101computing.net.
https://www.101computing.net/real-time-iss-tracker/

W3SCHOOLS. (2019). CSS Tutorial. W3schools.com. https://www.w3schools.com/css/

W3schools. (2018). Python Dictionaries. W3schools.com.
https://www.w3schools.com/python/python_dictionaries.asp

Weather Forecast API - 101 Computing. (2018, December 29). Www.101computing.net.
https://www.101computing.net/weather-forecast-api/

48

